<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="23">
		<Properties>
			<float name="AirDensity">0.00120000006</float>
			<bool name="AllowThirdPartySales">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AvatarUnificationMode">0</token>
			<token name="CSGAsyncDynamicCollision">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<token name="ClientAnimatorThrottling">0</token>
			<BinaryString name="CollisionGroupData">AQEABP////8HRGVmYXVsdA==</BinaryString>
			<Ref name="CurrentCamera">RBX1C18BFE8F7A742B6A47080B23F5CF1FD</Ref>
			<token name="DecreaseMinimumPartDensityMode">0</token>
			<bool name="DefinesCapabilities">false</bool>
			<double name="DistributedGameTime">0</double>
			<token name="EditorLiveScripting">0</token>
			<bool name="ExplicitAutoJoints">true</bool>
			<float name="FallenPartsDestroyHeight">-500</float>
			<token name="FluidForces">0</token>
			<Vector3 name="GlobalWind">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<float name="Gravity">196.199997</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<token name="IKControlConstraintSupport">0</token>
			<token name="LevelOfDetail">0</token>
			<token name="MeshPartHeadsAndAccessories">0</token>
			<CoordinateFrame name="ModelMeshCFrame">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<SharedString name="ModelMeshData">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
			<Vector3 name="ModelMeshSize">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
			</Vector3>
			<token name="ModelStreamingBehavior">0</token>
			<token name="ModelStreamingMode">0</token>
			<string name="Name">Workspace</string>
			<bool name="NeedsPivotMigration">false</bool>
			<token name="PhysicsSteppingMethod">0</token>
			<token name="PlayerCharacterDestroyBehavior">0</token>
			<token name="PrimalPhysicsSolver">0</token>
			<Ref name="PrimaryPart">null</Ref>
			<token name="RejectCharacterDeletions">0</token>
			<token name="ReplicateInstanceDestroySetting">0</token>
			<token name="Retargeting">0</token>
			<float name="ScaleFactor">1</float>
			<token name="SignalBehavior2">0</token>
			<int64 name="SourceAssetId">-1</int64>
			<token name="StreamOutBehavior">0</token>
			<bool name="StreamingEnabled">false</bool>
			<token name="StreamingIntegrityMode">0</token>
			<int name="StreamingMinRadius">64</int>
			<int name="StreamingTargetRadius">1024</int>
			<BinaryString name="Tags"></BinaryString>
			<bool name="TerrainWeldsFixed">true</bool>
			<bool name="TouchesUseCollisionGroups">false</bool>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000860d</UniqueId>
			<OptionalCoordinateFrame name="WorldPivotData">
				<CFrame>
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CFrame>
			</OptionalCoordinateFrame>
		</Properties>
		<Item class="Camera" referent="RBX1C18BFE8F7A742B6A47080B23F5CF1FD">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<CoordinateFrame name="CFrame">
					<X>42.1104507</X>
					<Y>35.293869</Y>
					<Z>-24.2728481</Z>
					<R00>-0.304052234</R00>
					<R01>0.687859118</R01>
					<R02>-0.659091949</R02>
					<R10>-0</R10>
					<R11>0.691847265</R11>
					<R12>0.722043991</R12>
					<R20>0.952655435</R20>
					<R21>0.219539091</R21>
					<R22>-0.210357666</R22>
				</CoordinateFrame>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<float name="FieldOfView">70</float>
				<token name="FieldOfViewMode">0</token>
				<CoordinateFrame name="Focus">
					<X>43.4286346</X>
					<Y>33.849781</Y>
					<Z>-23.8521328</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="HeadLocked">true</bool>
				<float name="HeadScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Camera</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">35e96ac358fec8160612c7810000860e</UniqueId>
				<bool name="VRTiltAndRollEnabled">false</bool>
			</Properties>
		</Item>
		<Item class="Part" referent="24">
			<Properties>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>-10</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4284636770</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Baseplate</string>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">35e96ac358fec8160612c7810000898b</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<token name="formFactorRaw">1</token>
				<token name="shape">1</token>
				<Vector3 name="size">
					<X>512</X>
					<Y>20</Y>
					<Z>512</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBXF78F48B48AA44A9EBAA328CB503667FB">
			<Properties>
				<token name="AcquisitionMethod">0</token>
				<bool name="Anchored">true</bool>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<CoordinateFrame name="CFrame">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<bool name="CanQuery">true</bool>
				<bool name="CanTouch">true</bool>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="CastShadow">true</bool>
				<string name="CollisionGroup">Default</string>
				<int name="CollisionGroupId">0</int>
				<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
				<PhysicalProperties name="CustomPhysicalProperties">
					<CustomPhysics>false</CustomPhysics>
				</PhysicalProperties>
				<bool name="Decoration">false</bool>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="EnableFluidForces">true</bool>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="GrassLength">0.699999988</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<bool name="Massless">false</bool>
				<token name="Material">256</token>
				<BinaryString name="MaterialColors"><![CDATA[AAAAAAAAan8/P39rf2Y/ilY+j35fi21PZmxvZbDqw8faiVpHOi4kHh4lZlw76JxKc3trhHta
gcLgc4RKxr21zq2UlJSM]]></BinaryString>
				<string name="MaterialVariantSerialized"></string>
				<string name="Name">Terrain</string>
				<BinaryString name="PhysicsGrid">AgMAAAAAAAAAAAAAAAA=</BinaryString>
				<CoordinateFrame name="PivotOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<int name="RootPriority">0</int>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<bool name="ShorelinesUpgraded">false</bool>
				<BinaryString name="SmoothGrid">AQU=</BinaryString>
				<bool name="SmoothVoxelsUpgraded">false</bool>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<UniqueId name="UniqueId">35e96ac358fec8160612c7810000898c</UniqueId>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Color3 name="WaterColor">
					<R>0.0500000007</R>
					<G>0.330000013</G>
					<B>0.360000014</B>
				</Color3>
				<float name="WaterReflectance">1</float>
				<float name="WaterTransparency">0.300000012</float>
				<float name="WaterWaveSize">0.150000006</float>
				<float name="WaterWaveSpeed">10</float>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
	</Item>
	<Item class="TimerService" referent="RBX07F92C7149D946329BE7CD9B694D59D9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TimerService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008919</UniqueId>
		</Properties>
	</Item>
	<Item class="SoundService" referent="19">
		<Properties>
			<token name="AmbientReverb">0</token>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<float name="DistanceFactor">3.32999992</float>
			<float name="DopplerScale">1</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">SoundService</string>
			<bool name="RespectFilteringEnabled">true</bool>
			<float name="RolloffScale">1</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000891a</UniqueId>
			<token name="VolumetricAudio">1</token>
		</Properties>
	</Item>
	<Item class="VideoCaptureService" referent="RBX79BBB79DA00147879EDA9366C1F4F396">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VideoCaptureService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000891b</UniqueId>
		</Properties>
	</Item>
	<Item class="NonReplicatedCSGDictionaryService" referent="RBXD525796A3F604084AF22B94ECC62F28F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">NonReplicatedCSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000891c</UniqueId>
		</Properties>
	</Item>
	<Item class="CSGDictionaryService" referent="RBX9DEE55F74F5B45A687A7018E8370DEB2">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CSGDictionaryService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000891d</UniqueId>
		</Properties>
	</Item>
	<Item class="Chat" referent="RBXAA66821B76374FE38696B0BB14FD3A46">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="BubbleChatEnabled">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadDefaultChat">true</bool>
			<string name="Name">Chat</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008922</UniqueId>
		</Properties>
	</Item>
	<Item class="Players" referent="RBXFF32E6CB52844846A92269DD3A0F8C75">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CharacterAutoLoads">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPlayersInternal">12</int>
			<string name="Name">Players</string>
			<int name="PreferredPlayersInternal">0</int>
			<float name="RespawnTime">5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008924</UniqueId>
			<bool name="UseStrafingAnimations">false</bool>
		</Properties>
	</Item>
	<Item class="ReplicatedFirst" referent="RBXCC20FFB446484246B896914CE401E1F5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedFirst</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008927</UniqueId>
		</Properties>
	</Item>
	<Item class="TweenService" referent="RBX16EE104C5F8B43A78C201BE753CB9247">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TweenService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008929</UniqueId>
		</Properties>
	</Item>
	<Item class="MaterialService" referent="RBX439DB0248F0E4897BF48061917C9C35A">
		<Properties>
			<string name="AsphaltName">Asphalt</string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<string name="BasaltName">Basalt</string>
			<string name="BrickName">Brick</string>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<string name="CardboardName">Cardboard</string>
			<string name="CarpetName">Carpet</string>
			<string name="CeramicTilesName">CeramicTiles</string>
			<string name="ClayRoofTilesName">ClayRoofTiles</string>
			<string name="CobblestoneName">Cobblestone</string>
			<string name="ConcreteName">Concrete</string>
			<string name="CorrodedMetalName">CorrodedMetal</string>
			<string name="CrackedLavaName">CrackedLava</string>
			<bool name="DefinesCapabilities">false</bool>
			<string name="DiamondPlateName">DiamondPlate</string>
			<string name="FabricName">Fabric</string>
			<string name="FoilName">Foil</string>
			<string name="GlacierName">Glacier</string>
			<string name="GraniteName">Granite</string>
			<string name="GrassName">Grass</string>
			<string name="GroundName">Ground</string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="IceName">Ice</string>
			<string name="LeafyGrassName">LeafyGrass</string>
			<string name="LeatherName">Leather</string>
			<string name="LimestoneName">Limestone</string>
			<string name="MarbleName">Marble</string>
			<string name="MetalName">Metal</string>
			<string name="MudName">Mud</string>
			<string name="Name">MaterialService</string>
			<string name="PavementName">Pavement</string>
			<string name="PebbleName">Pebble</string>
			<string name="PlasterName">Plaster</string>
			<string name="PlasticName">Plastic</string>
			<string name="RockName">Rock</string>
			<string name="RoofShinglesName">RoofShingles</string>
			<string name="RubberName">Rubber</string>
			<string name="SaltName">Salt</string>
			<string name="SandName">Sand</string>
			<string name="SandstoneName">Sandstone</string>
			<string name="SlateName">Slate</string>
			<string name="SmoothPlasticName">SmoothPlastic</string>
			<string name="SnowName">Snow</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000892a</UniqueId>
			<bool name="Use2022MaterialsXml">false</bool>
			<string name="WoodName">Wood</string>
			<string name="WoodPlanksName">WoodPlanks</string>
		</Properties>
	</Item>
	<Item class="TextChatService" referent="RBXB988DDF4D34448CE9312B10847A429B9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="ChatTranslationFTUXShown">true</bool>
			<bool name="ChatTranslationToggleEnabled">false</bool>
			<token name="ChatVersion">0</token>
			<bool name="CreateDefaultCommands">true</bool>
			<bool name="CreateDefaultTextChannels">true</bool>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TextChatService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000892b</UniqueId>
		</Properties>
		<Item class="ChatWindowConfiguration" referent="RBX05DC8154115645C181B80EA43405853A">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2999999999999999889</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/GothamSSm-Medium.otf</url></CachedFaceId>
				</Font>
				<float name="HeightScale">1</float>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="HorizontalAlignment">1</token>
				<string name="Name">ChatWindowConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">35e96ac358fec8160612c7810000898e</UniqueId>
				<token name="VerticalAlignment">1</token>
				<float name="WidthScale">1</float>
			</Properties>
		</Item>
		<Item class="ChatInputBarConfiguration" referent="RBXCB86FC30F3524620BD22D9795ACDAE36">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<bool name="AutocompleteEnabled">true</bool>
				<Color3 name="BackgroundColor3">
					<R>0.0980392173</R>
					<G>0.105882354</G>
					<B>0.113725491</B>
				</Color3>
				<double name="BackgroundTransparency">0.2000000000000000111</double>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/GothamSSm-Medium.otf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<token name="KeyboardKeyCode">47</token>
				<string name="Name">ChatInputBarConfiguration</string>
				<Color3 name="PlaceholderColor3">
					<R>0.698039234</R>
					<G>0.698039234</G>
					<B>0.698039234</B>
				</Color3>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<Ref name="TargetTextChannel">null</Ref>
				<Color3 name="TextColor3">
					<R>1</R>
					<G>1</G>
					<B>1</B>
				</Color3>
				<int64 name="TextSize">14</int64>
				<Color3 name="TextStrokeColor3">
					<R>0</R>
					<G>0</G>
					<B>0</B>
				</Color3>
				<double name="TextStrokeTransparency">0.5</double>
				<UniqueId name="UniqueId">35e96ac358fec8160612c7810000898f</UniqueId>
			</Properties>
		</Item>
		<Item class="BubbleChatConfiguration" referent="RBX574C6A15E6CE459C93D0708EA3B8EE22">
			<Properties>
				<string name="AdorneeName">HumanoidRootPart</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<Color3 name="BackgroundColor3">
					<R>0.980392158</R>
					<G>0.980392158</G>
					<B>0.980392158</B>
				</Color3>
				<double name="BackgroundTransparency">0.10000000000000000555</double>
				<float name="BubbleDuration">15</float>
				<float name="BubblesSpacing">6</float>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<bool name="Enabled">true</bool>
				<token name="Font">18</token>
				<Font name="FontFace">
					<Family><url>rbxasset://fonts/families/GothamSSm.json</url></Family>
					<Weight>500</Weight>
					<Style>Normal</Style>
					<CachedFaceId><url>rbxasset://fonts/GothamSSm-Medium.otf</url></CachedFaceId>
				</Font>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<Vector3 name="LocalPlayerStudsOffset">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="MaxBubbles">3</float>
				<float name="MaxDistance">100</float>
				<float name="MinimizeDistance">40</float>
				<string name="Name">BubbleChatConfiguration</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<bool name="TailVisible">true</bool>
				<Color3 name="TextColor3">
					<R>0.223529413</R>
					<G>0.23137255</G>
					<B>0.239215687</B>
				</Color3>
				<int64 name="TextSize">16</int64>
				<UniqueId name="UniqueId">35e96ac358fec8160612c78100008990</UniqueId>
				<float name="VerticalStudsOffset">0</float>
			</Properties>
		</Item>
	</Item>
	<Item class="PermissionsService" referent="RBX7A29CFA4BB2844ED96A1CCBF1F7005D7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PermissionsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000892f</UniqueId>
		</Properties>
	</Item>
	<Item class="PlayerEmulatorService" referent="RBXA4BE2728288B482CB70DE14CE9306690">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="CustomPoliciesEnabled">false</bool>
			<bool name="DefinesCapabilities">false</bool>
			<string name="EmulatedCountryCode"></string>
			<string name="EmulatedGameLocale"></string>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PlayerEmulatorService</string>
			<bool name="PlayerEmulationEnabled">false</bool>
			<bool name="PseudolocalizationEnabled">false</bool>
			<BinaryString name="SerializedEmulatedPolicyInfo"></BinaryString>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008931</UniqueId>
		</Properties>
	</Item>
	<Item class="StudioData" referent="RBX0C0650F8544F4DCDA5DCA4C908FA04C4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="EnableScriptCollabByDefaultOnLoad">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StudioData</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008935</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterPlayer" referent="20">
		<Properties>
			<bool name="AllowCustomAnimations">true</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoJumpEnabled">true</bool>
			<token name="AvatarJointUpgrade_Serialized">0</token>
			<float name="CameraMaxZoomDistance">400</float>
			<float name="CameraMinZoomDistance">0.5</float>
			<token name="CameraMode">0</token>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<float name="CharacterJumpHeight">7.19999981</float>
			<float name="CharacterJumpPower">50</float>
			<float name="CharacterMaxSlopeAngle">89</float>
			<bool name="CharacterUseJumpPower">true</bool>
			<float name="CharacterWalkSpeed">16</float>
			<token name="DeathStyle">0</token>
			<bool name="DefinesCapabilities">false</bool>
			<token name="DevCameraOcclusionMode">0</token>
			<token name="DevComputerCameraMovementMode">0</token>
			<token name="DevComputerMovementMode">0</token>
			<token name="DevTouchCameraMovementMode">0</token>
			<token name="DevTouchMovementMode">0</token>
			<token name="EnableDynamicHeads">0</token>
			<bool name="EnableMouseLockOption">true</bool>
			<int64 name="GameSettingsAssetIDFace">0</int64>
			<int64 name="GameSettingsAssetIDHead">0</int64>
			<int64 name="GameSettingsAssetIDLeftArm">0</int64>
			<int64 name="GameSettingsAssetIDLeftLeg">0</int64>
			<int64 name="GameSettingsAssetIDPants">0</int64>
			<int64 name="GameSettingsAssetIDRightArm">0</int64>
			<int64 name="GameSettingsAssetIDRightLeg">0</int64>
			<int64 name="GameSettingsAssetIDShirt">0</int64>
			<int64 name="GameSettingsAssetIDTeeShirt">0</int64>
			<int64 name="GameSettingsAssetIDTorso">0</int64>
			<token name="GameSettingsAvatar">1</token>
			<token name="GameSettingsR15Collision">0</token>
			<NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
			<NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
			<float name="HealthDisplayDistance">100</float>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadCharacterAppearance">true</bool>
			<token name="LoadCharacterLayeredClothing">0</token>
			<token name="LuaCharacterController">0</token>
			<string name="Name">StarterPlayer</string>
			<float name="NameDisplayDistance">100</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008937</UniqueId>
			<bool name="UserEmotesEnabled">true</bool>
		</Properties>
		<Item class="StarterPlayerScripts" referent="21">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterPlayerScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">35e96ac358fec8160612c78100008989</UniqueId>
			</Properties>
			<Item class="Folder" referent="22">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">Tests</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">35e96ac358fec8160612c7810000898a</UniqueId>
				</Properties>
				<Item class="ModuleScript" referent="RBX2DF87B82F1BD4CB8AD8DDACDF47E1AC3">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Setup</string>
						<string name="ScriptGuid">{F793253E-AD91-4DFD-8F1F-8E92B125C6E9}</string>
						<ProtectedString name="Source"><![CDATA[local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Packages = ReplicatedStorage:WaitForChild("Packages")
local Commander = require(Packages.Commander)
local Parameters = {
    Title = "WOw"

}

Commander.Window.WindowControl(Parameters)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">35e96ac358fec8160612c78100010fba</UniqueId>
					</Properties>
				</Item>
			</Item>
		</Item>
		<Item class="StarterCharacterScripts" referent="RBX824EE942B39B4688A90211A288D2250E">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">StarterCharacterScripts</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">35e96ac358fec8160612c7810000898d</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBXB4CE6123AC3B4D5B9D10E0DB6F17E8A5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterPack</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008938</UniqueId>
		</Properties>
	</Item>
	<Item class="StarterGui" referent="RBX5C633B609FC046FBA8A580BD49F79F88">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">StarterGui</string>
			<bool name="ResetPlayerGuiOnSpawn">true</bool>
			<token name="RtlTextSupport">0</token>
			<token name="ScreenOrientation">2</token>
			<bool name="ShowDevelopmentGui">true</bool>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008939</UniqueId>
			<token name="VirtualCursorMode">0</token>
		</Properties>
	</Item>
	<Item class="LocalizationService" referent="RBX67D63BA5C6524FC3834C6E4765FE6F30">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LocalizationService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000893d</UniqueId>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBXCCF98107BB0F4C7CA01BC2A7EBC359D4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Teleport Service</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008940</UniqueId>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBXA567E7E178174786BD2F034A69F7D81A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CollectionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008942</UniqueId>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBXF9AE2EAB78444C319FFB7D8DEA4C02E9">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">PhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008943</UniqueId>
		</Properties>
	</Item>
	<Item class="InsertService" referent="RBX435F403632194FB7B98AA5521E68459A">
		<Properties>
			<bool name="AllowClientInsertModels">false</bool>
			<bool name="AllowInsertFreeModels">false</bool>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">InsertService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008947</UniqueId>
		</Properties>
		<Item class="StringValue" referent="RBX129DA82C5FD44827BB9B44B3DB0C6659">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">InsertionHash</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">35e96ac358fec8160612c78100011d9b</UniqueId>
				<string name="Value">{003782DD-3B98-43A3-80ED-C3DA651353FB}</string>
			</Properties>
		</Item>
	</Item>
	<Item class="GamePassService" referent="RBX5D2F0221EDC9449D97EB3983AEBA0B2F">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">GamePassService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008948</UniqueId>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBXCF904BE3B99445AB8B77F2C9EF1AEF48">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008949</UniqueId>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX371059A0A61F47C28EA557E2D4A8CAA4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">CookiesService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000894a</UniqueId>
		</Properties>
	</Item>
	<Item class="VRService" referent="RBX833ECDA0AD244C1CA51C25CB3DD9409D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<token name="AutomaticScaling">0</token>
			<bool name="AvatarGestures">false</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="FadeOutViewOnCollision">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VRService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000894e</UniqueId>
		</Properties>
	</Item>
	<Item class="ContextActionService" referent="RBXE200B9356370430F9C06E9CA9A79957B">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ContextActionService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000894f</UniqueId>
		</Properties>
	</Item>
	<Item class="ScriptService" referent="RBXCC196D9B54D245839AF1391A4144CC15">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008950</UniqueId>
		</Properties>
	</Item>
	<Item class="AssetService" referent="RBX83D442E174B444C28CF7808F04A8EA36">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AssetService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008951</UniqueId>
		</Properties>
	</Item>
	<Item class="TouchInputService" referent="RBXB66725CF179546DAACCAA7EB697F547C">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">TouchInputService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008952</UniqueId>
		</Properties>
	</Item>
	<Item class="AnalyticsService" referent="RBX97EADE03C695406EB7E7CDB493A571DE">
		<Properties>
			<string name="ApiKey"></string>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">AnalyticsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008955</UniqueId>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX1913E708B5E843FB812F8D70BD7238FA">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Selection</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008957</UniqueId>
		</Properties>
	</Item>
	<Item class="ServerScriptService" referent="17">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LoadStringEnabled">false</bool>
			<string name="Name">ServerScriptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008958</UniqueId>
		</Properties>
		<Item class="Folder" referent="18">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Tests</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">35e96ac358fec8160612c78100008988</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="RBX67D6607CB3AE47AEA620C7A2B2189C46">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">CommanderServer</string>
					<string name="ScriptGuid">{C41B047B-E275-44C0-98F6-400E50E0E4F2}</string>
					<ProtectedString name="Source"></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">35e96ac358fec8160612c781000106d3</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="ServerStorage" referent="RBX9E7FAA58E25B451088D42052D5F07C2D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServerStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008959</UniqueId>
		</Properties>
		<Item class="Folder" referent="RBXEA3D20C490774D748DA01D4CFD8C34DD">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">LunarSound2</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">35e96ac358fec8160612c7810000dab0</UniqueId>
			</Properties>
		</Item>
		<Item class="Configuration" referent="RBX046C7A6DFCCD4D2B96D9B54C5F5C6A24">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Library_Container</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">35e96ac358fec8160612c7810000dab3</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="ReplicatedStorage" referent="1">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ReplicatedStorage</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000895a</UniqueId>
		</Properties>
		<Item class="Folder" referent="2">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">Packages</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">35e96ac358fec8160612c78100008978</UniqueId>
			</Properties>
			<Item class="ModuleScript" referent="3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Commander</string>
					<string name="ScriptGuid">{3AE55882-BB7A-46C0-BF2E-5B4D7ED0B42D}</string>
					<ProtectedString name="Source"><![CDATA[return {
	
}]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">35e96ac358fec8160612c78100008979</UniqueId>
				</Properties>
				<Item class="Folder" referent="4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Client</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">35e96ac358fec8160612c7810000897a</UniqueId>
					</Properties>
					<Item class="Folder" referent="5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">UI</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">35e96ac358fec8160612c7810000897b</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Header</string>
								<string name="ScriptGuid">{D521770C-0068-4C90-8FC5-534ADBAEA765}</string>
								<ProtectedString name="Source"><![CDATA[local UI = script.Parent
local CommanderPkg = script.Parent.Parent.Parent
local Packages = CommanderPkg.Parent

local Fusion = require(Packages.Fusion)
local ThemeProvider = require(UI.ThemeProvider)

local New = Fusion.New
local Children = Fusion.Children

return function(params)
    return New "Frame" {
        BackgroundColor3 = ThemeProvider.Color.HeaderBackground,
        BackgroundTransparency = 0,
        BorderSizePixel = 0,
        Size = UDim2.new(1, 0, 0, 40),
        ZIndex = params.ZIndex or 0,

        [Children] = {
            New "UIStroke" {
                Color = ThemeProvider.Color.Separator,
                Thickness = 2,
            },

            New "Frame" {
                BackgroundTransparency = 1,
                Size = UDim2.fromScale(1, 1),

                [Children] = {
                    New "UIListLayout" {
                        Padding = UDim.new(0, 1),
                        FillDirection = Enum.FillDirection.Horizontal,
                        HorizontalAlignment = Enum.HorizontalAlignment.Right,
                        SortOrder = Enum.SortOrder.LayoutOrder,
                    },

                    params.Right[Children],
                }
            },

            New "Frame" {
                BackgroundTransparency = 1,
                Size = UDim2.fromScale(1, 1),

                [Children] = {
                    New "UIListLayout" {
                        Padding = UDim.new(0, 1),
                        FillDirection = Enum.FillDirection.Horizontal,
                        SortOrder = Enum.SortOrder.LayoutOrder,
                    },

                    params.Left[Children],
                }
            },
        }
    }
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c7810000897c</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">HeaderItem</string>
									<string name="ScriptGuid">{A930941C-757E-48C7-8AD7-C3D2E7CA7E73}</string>
									<ProtectedString name="Source"><![CDATA[local UI = script.Parent.Parent
local CommanderPkg = script.Parent.Parent.Parent.Parent
local Packages = CommanderPkg.Parent

local Fusion = require(Packages.Fusion)
local ThemeProvider = require(UI.ThemeProvider)

local New = Fusion.New
local Children = Fusion.Children
local OnEvent = Fusion.OnEvent
local State = Fusion.State

return function(params)
    local buttonTransparencyState = State(1)
    return New "TextButton" {
        Text = "",
        BackgroundColor3 = Color3.new(0, 0, 0),
        BackgroundTransparency = buttonTransparencyState,
        Size = UDim2.fromScale(1, 1),
        LayoutOrder = params.LayoutOrder or 0,
        ZIndex = params.ZIndex or 0,

        [Children] = {
            New "UIAspectRatioConstraint" { },

            New "ImageLabel" {
                Image = params.Image,
                ImageColor3 = ThemeProvider.Color.HeaderText,
                AnchorPoint = Vector2.new(0.5, 0.5),
                BackgroundTransparency = 1,
                Position = UDim2.fromScale(0.5, 0.5),
                Size = UDim2.fromScale(0.5, 0.5),
            },

            New "UIStroke" {
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                Color = ThemeProvider.Color.Separator,
            },
        },

        [OnEvent "MouseEnter"] = function()
            buttonTransparencyState:set(0.95)
        end,

        [OnEvent "MouseLeave"] = function()
            buttonTransparencyState:set(1)
        end,

        [OnEvent "MouseButton1Down"] = function()
            buttonTransparencyState:set(0.85)
        end,

        [OnEvent "MouseButton1Click"] = function()
            buttonTransparencyState:set(1)
            if params.OnClick then params.OnClick() end
        end,
    }
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810000897d</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="8">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Table</string>
								<string name="ScriptGuid">{FAB00983-9499-4925-9A14-C47190920205}</string>
								<ProtectedString name="Source"><![CDATA[local UI = script.Parent
local CommanderPkg = script.Parent.Parent.Parent
local Packages = CommanderPkg.Parent

local Fusion = require(Packages.Fusion)
local ThemeProvider = require(UI.ThemeProvider)

local New = Fusion.New
local Children = Fusion.Children
local Computed = Fusion.Computed

return function(params)
    return New "Frame" {
        AutomaticSize = Enum.AutomaticSize.Y,
        BackgroundTransparency = 1,
        LayoutOrder = params.LayoutOrder or 0,
        Size = UDim2.fromScale(1, 0),
        Visible = Computed(function()
            return next(params[Children]:get()) ~= nil
        end),

        [Children] = {
            New "TextLabel" {
                Font = ThemeProvider.Font.Headline.Type,
                TextSize = ThemeProvider.Font.Headline.Size,
                Text = params.Title,
                TextColor3 = ThemeProvider.Color.AltAltText,
                TextXAlignment = Enum.TextXAlignment.Left,
                AutomaticSize = Enum.AutomaticSize.Y,
                Visible = Computed(function()
                    return params.Title:get() and params.Title:get() ~= ""
                end),
                BackgroundTransparency = 1,
                Size = UDim2.new(1, 0, 0, 16),
            },

            New "UIPadding" {
                PaddingBottom = UDim.new(0, 12),
                PaddingLeft = UDim.new(0, 24),
                PaddingRight = UDim.new(0, 24),
            },

            New "UIListLayout" {
                Padding = UDim.new(0, 8),
                SortOrder = Enum.SortOrder.LayoutOrder,
            },

            New "Frame" {
                AutomaticSize = Enum.AutomaticSize.Y,
                BackgroundColor3 = ThemeProvider.Color.TableBackground,
                ClipsDescendants = true,
                LayoutOrder = 1,
                Size = UDim2.fromScale(1, 0),

                [Children] = {
                    New "UICorner" {
                        CornerRadius = UDim.new(0, 6),
                    },

                    New "UIStroke" {
                        Color = ThemeProvider.Color.Separator,
                    },

                    New "UIListLayout" {
                        Padding = UDim.new(0, 1),
                        SortOrder = Enum.SortOrder.LayoutOrder,
                    },

                    New "UIPadding" {
                        PaddingTop = UDim.new(0, 1),
                    },

                    params[Children],
                }
            },
        }
    }
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c7810000897e</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TableItem</string>
									<string name="ScriptGuid">{B9B8A8F8-071A-4267-B8DE-804151CFCE8C}</string>
									<ProtectedString name="Source"><![CDATA[local UI = script.Parent.Parent
local CommanderPkg = script.Parent.Parent.Parent.Parent
local Packages = CommanderPkg.Parent

local Fusion = require(Packages.Fusion)
local ThemeProvider = require(UI.ThemeProvider)

local New = Fusion.New
local Children = Fusion.Children
local OnEvent = Fusion.OnEvent
local State = Fusion.State
local Computed = Fusion.Computed

local function leftTableItem(params)
	return New "Frame" {
		AutomaticSize = Enum.AutomaticSize.X,
		BackgroundTransparency = 1,
		Size = UDim2.new(0.75, 0, 0, 46),

		[Children] = {
			New "UIListLayout" {
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			},

			New "UIPadding" {
				PaddingLeft = UDim.new(0, 9),
			},

			New "TextLabel" {
				Font = ThemeProvider.Font.Body.Type,
				TextColor3 = ThemeProvider.Color.MainText,
				TextSize = ThemeProvider.Font.Body.Size,
				TextWrapped = true,
				Text = params.Title,
				TextXAlignment = Enum.TextXAlignment.Left,
				AutomaticSize = Enum.AutomaticSize.X,
				BackgroundTransparency = 1,
				Size = UDim2.new(1, 0, 0, 14),
			},

			New "TextLabel" {
				Font = ThemeProvider.Font.Subheadline.Type,
				TextColor3 = ThemeProvider.Color.AltText,
				TextSize = ThemeProvider.Subheadline.Size,
				TextWrapped = true,
				Text = params.Description,
				Visible = Computed(function()
					return params.Description:get() and params.Description:get() ~= ""
				end),
				TextXAlignment = Enum.TextXAlignment.Left,
				AutomaticSize = Enum.AutomaticSize.Y,
				BackgroundTransparency = 1,
				LayoutOrder = 1,
				Size = UDim2.new(1, 0, 0, 14),
			}
		}
	}
end

local function rightTableItem(params)
	return New "Frame" {
		BackgroundTransparency = 1,
		Size = UDim2.new(0.25, 0, 0, 46),

		[Children] = {
			New "UIListLayout" {
				FillDirection = Enum.FillDirection.Horizontal,
				HorizontalAlignment = Enum.HorizontalAlignment.Right,
				SortOrder = Enum.SortOrder.LayoutOrder,
				VerticalAlignment = Enum.VerticalAlignment.Center,
			},

			New "UIPadding" {
				PaddingRight = UDim.new(0, 9),
			},

			params[Children],
		}
	}
end

return function(params)
	local buttonTransparencyState = State(1)
	return New "TextButton" {
		AutomaticSize = Enum.AutomaticSize.Y,
		BackgroundColor3 = Color3.new(0, 0, 0),
		BackgroundTransparency = buttonTransparencyState,
		Text = "",
		LayoutOrder = params.LayoutOrder or 1,
		Size = UDim2.new(1, 0, 0, 46),

		[Children] = {
			New "Frame" {
				BackgroundColor3 = ThemeProvider.Color.Separator,
				BorderSizePixel = 0,
				Position = UDim2.fromScale(0, 1),
				Size = UDim2.new(1, 0, 0, 1),
			},

			rightTableItem(params),

			leftTableItem(params),
		},

		[OnEvent "MouseEnter"] = function()
			buttonTransparencyState:set(0.95)
		end,

		[OnEvent "MouseLeaave"] = function()
			buttonTransparencyState:set(1)
		end,

		[OnEvent "MouseButton1Down"] = function()
			buttonTransparencyState:set(0.85)
		end,

		[OnEvent "MouseButton1Click"] = function()
			buttonTransparencyState:set(1)
			if params.OnClick then params.OnClick() end
		end,
	}
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810000897f</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="10">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">TextButton</string>
								<string name="ScriptGuid">{4DC45257-DDCA-4AFC-8035-89A3F14BF7BB}</string>
								<ProtectedString name="Source"><![CDATA[local UI = script.Parent
local CommanderPkg = script.Parent.Parent.Parent
local Packages = CommanderPkg.Parent

local Fusion = require(Packages.Fusion)
local ThemeProvider = require(UI.ThemeProvider)

local New = Fusion.New
local Children = Fusion.Children
local OnEvent = Fusion.OnEvent
local State = Fusion.State
local Computed = Fusion.Computed

return function(params)
    local buttonTransparencyState = State(1)
    return New "TextButton" {
        Text = "",
        AutomaticSize = Enum.AutomaticSize.X,
        BackgroundColor3 = ThemeProvider.Color.ButtonBackground,
        LayoutOrder = params.LayoutOrder,
        Size = UDim2.fromOffset(0, 38),

        [Children] = {
            New "UICorner" {
                CornerRadius = UDim.new(0, 6),
            },

            New "UIStroke" {
                ApplyStrokeMode = Enum.ApplyStrokeMode.Border,
                Color = ThemeProvider.Color.Separator,
            },

            New "Frame" {
                AutomaticSize = Enum.AutomaticSize.X,
                BackgroundColor3 = Color3.new(0, 0, 0),
                BackgroundTransparency = buttonTransparencyState,
                BorderSizePixel = 0,
                Size = UDim2.fromScale(0, 1),

                [Children] = {
                    New "UIPadding" {
                        PaddingBottom = UDim.new(0, 12),
                        PaddingLeft = UDim.new(0, 24),
                        PaddingRight = UDim.new(0, 24),
                        PaddingTop = UDim.new(0, 12),
                    },

                    New "UIListLayout" {
                        FillDirection = Enum.FillDirection.Horizontal,
                        SortOrder = Enum.SortOrder.LayoutOrder,
                        VerticalAlignment = Enum.VerticalAlignment.Center,
                    },

                    New "TextLabel" {
                        Font = ThemeProvider.Font.Body.Type,
                        TextColor3 = ThemeProvider.Color.MainText,
                        TextSize = ThemeProvider.Font.Body.Size,
                        TextWrapped = true,
                        Text = params.Title,
                        AutomaticSize = Enum.AutomaticSize.X,
                        BackgroundTransparency = 1,
                        LayoutOrder = 1,
                        Size = UDim2.fromOffset(0, 14),
                    },

                    New "ImageLabel" {
                        Image = params.Icon,
                        ImageColor3 = ThemeProvider.Color.MainText,
                        BackgroundTransparency = 1,
                        Size = UDim2.fromOffset(18, 18),
                        Visible = Computed(function()
                            return params.Icon:get() ~= ""
                        end),
                    },

                    New "UICorner" {
                        CornerRadius = UDim.new(0, 6),
                    },
                }
            }
        },

        [OnEvent "MouseEnter"] = function()
            buttonTransparencyState:set(0.95)
        end,

        [OnEvent "MouseLeaave"] = function()
            buttonTransparencyState:set(1)
        end,

        [OnEvent "MouseButton1Down"] = function()
            buttonTransparencyState:set(0.85)
        end,

        [OnEvent "MouseButton1Click"] = function()
            buttonTransparencyState:set(1)
            if params.OnClick then params.OnClick() end
        end,
    }
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100008980</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="11">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ThemeProvider</string>
								<string name="ScriptGuid">{281D850F-03F3-4BCF-971B-84F08E04AFDA}</string>
								<ProtectedString name="Source">return require(script.Parent.Themes.Light) -- Actual theme switching to be done in future releases.</ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100008981</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="12">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Themes</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100008982</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="13">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Light</string>
									<string name="ScriptGuid">{8B819ED7-A637-4E6C-9490-732E4D8CA4E3}</string>
									<ProtectedString name="Source"><![CDATA[return {
	Color = {
	    WindowControlBackground = Color3.fromRGB(230, 230, 230),
		MainBackground = Color3.fromRGB(245, 245, 245),
		TableBackground = Color3.fromRGB(255, 255, 255),
		DangerBackground = Color3.fromRGB(252, 33, 37),
		HeaderBackground = Color3.fromRGB(250, 250, 250),
		ButtonBackground = Color3.fromRGB(255, 255, 255),
		MenuBackground = Color3.fromRGB(255, 255, 255),
		Separator = Color3.fromRGB(200, 200, 200),

		MainText = Color3.fromRGB(0, 0, 0),
		AltText = Color3.fromRGB(100, 100, 100),
		AltAltText = Color3.fromRGB(150, 150, 150),
		DangerText = Color3.fromRGB(215, 28, 31),
		SelectedText = Color3.fromRGB(255, 255, 255),
		HeaderText = Color3.fromRGB(150, 150, 150),
	},

	["Font"] = {
		Heading1 = {
			Type = Enum.Font.GothamBold,
			Size = 24,
		},
		Heading2 = {
			Type = Enum.Font.GothamSemibold,
			Size = 20,
		},
		FootnoteText = {
			Type = Enum.Font.Gotham,
			Size = 14,
		},
		Body = {
			Type = Enum.Font.GothamSemibold,
			Size = 14,
		},
		Headline = {
			Type = Enum.Font.GothamBold,
			Size = 14,
		},
		Subheadline = {
			Type = Enum.Font.Gotham,
			Size = 14,
		},
		HeaderText = {
			Type = Enum.Font.GothamSemibold,
			Size = 16,
		},
		MenuText = {
			Type = Enum.Font.GothamSemibold,
			Size = 16,
		},
	}
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100008983</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="14">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Window</string>
								<string name="ScriptGuid">{B9F10A6A-BBC1-4B71-A893-A98AAACA0C26}</string>
								<ProtectedString name="Source"><![CDATA[local UI = script.Parent
local CommanderPkg = script.Parent.Parent.Parent
local Packages = CommanderPkg.Parent

local Fusion = require(Packages.Fusion)
local ThemeProvider = require(UI.ThemeProvider)

local New = Fusion.New
local Children = Fusion.Children

local function windowControl(params)
    return New "Frame" {
        BackgroundColor3 = ThemeProvider.Color.WindowControlBackground,
        BorderSizePixel = 0,
        Size = UDim2.new(1, 0, 0, 32),

        [Children] = {
            New "UIStroke" {
                Color = ThemeProvider.Color.Separator,
            },

            New "UIPadding" {
                PaddingTop = UDim.new(0, 1),
            },

            New "TextLabel" {
                BackgroundTransparency = 1,
                Text = params.Title or "Window",
                Font = ThemeProvider.Font.Headline.Type,
                TextSize = ThemeProvider.Font.Headline.Size,
                TextColor3 = ThemeProvider.Color.AltText,
                TextXAlignment = Enum.TextXAlignment.Left,
                Size = UDim2.fromScale(0, 1),
                Position = UDim2.fromOffset(9, 0),
            },

            New "TextButton" {
                BackgroundTransparency = 1,
                Text = "",
                AnchorPoint = Vector2.new(1, 0),
                Size = UDim2.fromScale(1, 1),
                Position = UDim2.fromScale(1, 0),

                [Children] = {
                    New "ImageLabel" {
                        BackgroundTransparency = 1,
                        Image = "rbxassetid://10747384394",
                        ImageColor3 = ThemeProvider.Color.AltText,
                        AnchorPoint = Vector2.new(0.5, 0.5),
                        Size = UDim2.fromScale(0.6, 0.6),
                        Position = UDim2.fromScale(0.5, 0.5),
                    },

                    New "UIAspectRatioConstraint" {
                        AspectRatio = 1,
                    },
                },
            },

            New "TextButton" {
                Text = "",
                AnchorPoint = Vector2.new(0.5, 0),
                BackgroundTransparency = 1,
                Position = UDim2.fromScale(0.5, 0),
                Size = UDim2.fromScale(0.15, 1),

                [Children] = {
                    New "ImageButton" {
                        Image = "rbxassetid://2935604064",
                        ImageColor3 = ThemeProvider.Color.AltAltText,
                        ScaleType = Enum.ScaleType.Slice,
                        SliceCenter = Rect.new(256, 256, 256, 256),
                        AnchorPoint = Vector2.new(0, 0.5),
                        BackgroundTransparency = 1,
                        Position = UDim2.fromScale(0, 0.5),
                        Size = UDim2.new(1, 0, 0, 2),
                    },
                },
            },
        }
    }
end

return function(params)
	return New "CanvasGroup" {
		GroupTransparency = params.GroupTransparency,
		BackgroundColor3 = ThemeProvider.Color.MainBackground,
		BorderSizePixel = 0,
		Size = UDim2.fromScale(1, 1),
		Parent = params.Parent,

		[Children] = {
			New "UICorner" {
				CornerRadius = UDim.new(0, 6),
			},

			New "UIStroke" {
				Color = Color3.new(0, 0, 0),
				Thickness = 2,
				Transparency = 0.8,
			},

			New "UISizeConstraint" {
				MinSize = params.MinSize or Vector2.new(450, 300)
			},

			New "UIAspectRatioConstraint" {
				AspectRatio = params.AspectRatio or 1.3,
				AspectType = Enum.AspectType.ScaleWithParentSize,
				DominantAxis = Enum.DominantAxis.Height,
			},

			windowControl {

            },

            New "Frame" {
                BackgroundTransparency = 1,
                Size = UDim2.new(1, 0, 1, -32),
                Position = UDim2.fromOffset(0, 32),

                [Children] = params[Children]
            }
		},
	}
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100008984</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="15">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Window.story</string>
								<string name="ScriptGuid">{DE562D9E-19AA-4653-B510-8800D4D9C86B}</string>
								<ProtectedString name="Source"><![CDATA[local UI = script.Parent
local CommanderPkg = script.Parent.Parent.Parent
local Packages = CommanderPkg.Parent

local Fusion = require(Packages.Fusion)
local ThemeProvider = require(UI.ThemeProvider)

local New = Fusion.New
local Children = Fusion.Children

local component = require(script.Parent.Window)
local headerComp = require(script.Parent.Header)
local headerItemComp = require(script.Parent.Header.HeaderItem)

return function(target)
    local newComp = component {
        Parent = target,

        [Children] = {
            headerComp {
                Left = {
                    [Children] = {
                        headerItemComp {
                            Image = "rbxassetid://7734058165",
                        }
                    }
                },
                Right = {
                    [Children] = {
                        headerItemComp {
                            Image = "rbxassetid://7734052925",
                        },

                        headerItemComp {
                            LayoutOrder = 1,
                            Image = "rbxassetid://7743876054",
                        },
                    }
                },
            }
        }
    }
    
    return function()
        newComp:Destroy()
    end
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100008985</UniqueId>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXADD5FC200AE8443A9CAFA522B8C58024">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">System</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">35e96ac358fec8160612c78100010f78</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBXCE22F875C92A43778FDFD112E80600EE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Bootstrap</string>
								<string name="ScriptGuid">{44CEBFAD-1973-4D07-8E63-0F5724113716}</string>
								<ProtectedString name="Source"><![CDATA[local Commander = require(script.Parent.Parent.Parent)
local Window = Commander.Window
local Parameters = {
    Title = "WOw"

}

local self = {}

        
    function self.Init(Parameters)
        Window(Parameters)
    end

return self]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100010f9c</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="16">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Server</string>
						<string name="ScriptGuid">{0F17E255-7342-49AA-94D1-FBF3CEE7D2CE}</string>
						<ProtectedString name="Source"><![CDATA[local Server = {}

function Server.start()
    
end

return Server
]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">35e96ac358fec8160612c78100008986</UniqueId>
					</Properties>
				</Item>
				<Item class="Folder" referent="RBX2D61BDBDD257459CBE91CF0CD13A78BB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">Events</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">35e96ac358fec8160612c781000112d6</UniqueId>
					</Properties>
					<Item class="RemoteEvent" referent="RBXDBD0680C08254C46A256FB84C4D95A39">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<string name="Name">PlayerAdd</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">35e96ac358fec8160612c781000112d7</UniqueId>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX50D9D4E6BA5C4A1F81166046106499BF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<string name="Name">_Index</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">35e96ac358fec8160612c78100010667</UniqueId>
				</Properties>
				<Item class="Folder" referent="RBXDEBE902EB4A448A496FBB528978F35A7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">7kayoh_koute@1.0.2</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">35e96ac358fec8160612c78100010668</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXAA63B5A91DA74AA587F351DF43F19A26">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Fusion</string>
							<string name="ScriptGuid">{CBF747DF-C0C8-4CCF-8AE0-98B707979A11}</string>
							<ProtectedString name="Source"><![CDATA[return require(script.Parent.Parent["elttob_fusion@0.1.1-beta"]["fusion"])
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">35e96ac358fec8160612c78100010669</UniqueId>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXD82F6D925B5A45C8AAD2DB79B54C7752">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">koute</string>
							<string name="ScriptGuid">{0EEDC959-A00B-4EFB-AD3B-D2720E0FAF77}</string>
							<ProtectedString name="Source"><![CDATA[local Types = require(script.Types)

local Route = require(script.Route)
local Router = require(script.Router)
local Meta = require(script.Meta)
local Canvas = require(script.Canvas)

return {
    _version = "1.0.2",
    Meta = Meta,
    Route = Route,
    Router = Router,
    Canvas = Canvas
} :: Types.Koute
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">35e96ac358fec8160612c7810001066a</UniqueId>
						</Properties>
						<Item class="ModuleScript" referent="RBX057E55D288F549738A07428EF436A0AC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Canvas</string>
								<string name="ScriptGuid">{0B4E745F-F19B-4DE3-A57D-BB1C1CB61F2F}</string>
								<ProtectedString name="Source"><![CDATA[local Packages = script.Parent.Parent
local Fusion = require(Packages.Fusion)

local New = Fusion.New
local State = Fusion.State
local Compat = Fusion.Compat
local Children = Fusion.Children

local function isDeprecated(props)
    for i, v in {Source = "source", PostRender = "postRender", PreRender = "preRender"} do
        if props[i] then
            warn(("props.%s is deprecated and will soon be removed, please use props.%s"):format(i, v))
            props[v] = props[i]
        end
    end
end

local function Canvas(props)
    isDeprecated(props)
    -- Fusion.Computed lacks destructor function atm, will switch to Fusion.Computed implementation in the future
    local children = State(nil)
    Compat(props.source.serving.view):onChange(function()
        if props.preRender then
            props.preRender()
        end
        -- Fusion.State is not equipped with destructor function, must be cleaned up manually for now
        if typeof(children:get()) == "Instance" then
            children:get():Destroy()
        end
        children:set(props.source.serving.view:get()(props.source, props.source.serving))
        if props.postRender then
            props.postRender()
        end
    end)

    return New "Frame" {
        BackgroundTransparency = 1,
        Size = UDim2.fromScale(1, 1),

        [Children] = children
    }
end

return Canvas
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c7810001066b</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXA9C627BFA6A0461DBAD89277ACC3A68D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Meta</string>
								<string name="ScriptGuid">{F0D04A4B-2991-4887-9426-DE3A105159B7}</string>
								<ProtectedString name="Source"><![CDATA[local function Meta(fieldName)
    return {
        type = "Symbol",
        name = "Meta",
        key = fieldName
    }
end

return Meta
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c7810001066c</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXAAA61DB551F24A75910748DF9E407119">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">doesMetaContainForbiddenValue</string>
									<string name="ScriptGuid">{0E49A11C-8211-4AE3-BBE0-4085EF200B02}</string>
									<ProtectedString name="Source"><![CDATA[local FORBIDDEN_META_VALUES = {"Instance", "Function"}

local function doesMetaContainForbiddenValue(value)
    local forbiddenMetaType = table.find(FORBIDDEN_META_VALUES, typeof(value))
    assert(forbiddenMetaType, typeof(forbiddenMetaType) .. " is unacceptable in Koute.Meta")
end

return doesMetaContainForbiddenValue]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001066d</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX536D680B2B9A4CE5B34B2BE81907A5E3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Route</string>
								<string name="ScriptGuid">{19B725A7-0910-4D69-8BE4-4700DF48FA93}</string>
								<ProtectedString name="Source"><![CDATA[local function Route(routePath)
    return function(parameters)
        parameters.type = "Route"
        parameters.path = routePath
        return parameters
    end
end

return Route
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c7810001066e</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX60C5DF62594947228D176E9E7DAC28F8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">deconstructRoute</string>
									<string name="ScriptGuid">{88729671-0B7F-4D6F-A5DB-0D33F3F354F6}</string>
									<ProtectedString name="Source"><![CDATA[local Koute = script.Parent.Parent
local Packages = script.Parent.Parent.Parent
local Fusion = require(Packages.Fusion)
local doesMetaContainForbiddenValue = require(Koute.Meta.doesMetaContainForbiddenValue)
local formatPath = require(script.Parent.formatPath)

local Children = Fusion.Children

local IGNORED_KEYS = {"view", "path", "meta", "type", Children}

local function deconstructRoute(route, prevPath: string?)
    assert(type(route.view) == "function", "Koute.Route.view expects a function")
    assert(type(route.path) == "string", "Koute.Route.path expects a string")
    assert(route._isProcessed ~= true, "this route is already processed and belongs to another route")
    if prevPath then
        route.path = prevPath .. route.path
    end
    route.path = formatPath(route.path)
    local toBind = {}

    for key, value in route do
        if table.find(IGNORED_KEYS, key) then
            continue
        -- leaving for future updates which may use Symbol
        elseif typeof(key) == "table" and key.type == "Symbol" then
            if key.name == "Meta" then
                doesMetaContainForbiddenValue(value)
                toBind[key.name] = value
                route[key] = nil
            else
                error(key.name .. " is not an acceptable symbol value in Koute.Route")
            end
        else
            error(typeof(key) .. " is not an acceptable value in Koute.Route")
        end
    end
    route.meta = toBind

    local children = route[Children]
    if children then
        for _, child in children do
            deconstructRoute(child, route.path)
        end
    end
end

return deconstructRoute
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001066f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF410B80C292D4A2790C877E49492BF43">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">formatPath</string>
									<string name="ScriptGuid">{405F7E66-6835-4473-BF7C-6CB7C1161B94}</string>
									<ProtectedString name="Source"><![CDATA[local function formatPath(path: string): string
    if path:sub(-1, -1) == "/" then
        path = path:sub(1, -2)
    end
    if path:sub(1, 1) ~= "/" then
        path ..= "/" .. path
    end
    return path
end

return formatPath
]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010670</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX6505248C24D548B1A077F92B4455DD71">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Router</string>
								<string name="ScriptGuid">{DC799A17-86FF-486F-AC2B-71DF8BB891A2}</string>
								<ProtectedString name="Source"><![CDATA[local Koute = script.Parent
local Packages = script.Parent.Parent

local Types = require(script.Parent.Types)
local Fusion = require(Packages.Fusion)
local deconstructRoute = require(Koute.Route.deconstructRoute)
local formatPath = require(Koute.Route.formatPath)
local doesMetaContainForbiddenValue = require(Koute.Meta.doesMetaContainForbiddenValue)

local State = Fusion.State
local Compat = Fusion.Compat
local Children = Fusion.Children

local class = {
	type = "router",
	history = {},
	serving = {
		path = State(""),
		view = State(),
		meta = State({}),
		params = {},
	},
	routes = {},
}
class.__index = class
local currentlyAt = 1

local function updateServing(class: Types.Router, route: Types.DeconstructedRoute, params: { any })
	class.serving.path:set(route.path)
	class.serving.meta:set(route.meta)
	class.serving.params = params
	class.serving.view:set(route.view)
end

local function unpackRoutes(route)
	local routes = {}
	table.insert(routes, route)

	if route[Children] then
		for _, child in route[Children] do
			for _, child in unpackRoutes(child) do
				table.insert(routes, child)
			end
		end
	end

	for _, route in routes do
		route[Children] = nil
	end
	
	return routes
end

function class:set(route: Types.DeconstructedRoute, params: { any }, direction: string)
	if direction == "go" and currentlyAt ~= #self.history then
		for i = currentlyAt + 1, #self.history do
			table.remove(self.history, i)
		end
		currentlyAt = #self.history
	end

	updateServing(self, route, params)

	if direction == "go" then
		currentlyAt += 1
		local archivedRoute = table.clone(route)
		archivedRoute.params = params
		table.insert(self.history, archivedRoute)
	end
end

function class:go(path: string, params: { any }?)
	local route = self.routes[formatPath(path)]
	assert(route, "this route does not exist")
	class:set(route, params or {}, "go")
end

function class:back(level: number?)
	level = level or 1
	local route = self.history[currentlyAt - level]
	assert(route, "history route does not exist")
	currentlyAt = #self.history - level
	class:set(route, route.params, "back")
end

return function(params)
	local router = setmetatable({}, class)
	for _, route in params.routes do
		deconstructRoute(route)
		for _, route in unpackRoutes(route) do
			router.routes[route.path] = route
		end
	end

	Compat(router.serving.meta):onChange(function()
		for _, meta in router.serving.meta:get() do
			doesMetaContainForbiddenValue(meta)
		end
	end)

	return router
end
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100010671</UniqueId>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXDF4E69D29BEE4EA5965C32D2B1D7668D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Types</string>
								<string name="ScriptGuid">{D1203347-2DA0-4AFF-A7F7-778907BC24A7}</string>
								<ProtectedString name="Source"><![CDATA[local Packages = script.Parent.Parent
local Fusion = require(Packages.Fusion)

type State = Fusion.State

export type DeconstructedRoute = {
    type: string,
    path: string,
    view: ({ any }) -> (Instance),
    meta: { [string]: any },
    [any]: any,
}

export type Route = {
    type: string,
    path: string,
    view: ({ any }) -> (Instance),
    [any]: any,
}

export type RouteParams = {
    view: ({ any }) -> (Instance),
    [any]: any,
}

export type Router = {
    type: string,
    history: {},
    serving: {
        path: State,
        view: State,
        meta: State,
        params: { any },
    },
    routes: { DeconstructedRoute? },

    go: (Router, string, { any }) -> (),
    back: (Router, number?) -> (),
    set: (Router, DeconstructedRoute, { any }, string) -> (),
}

export type RouterParams = {
    routes: { Route },
}

export type CanvasParams = {
    source: Router,
    preRender: () -> ()?,
    postRender: () -> ()?,
}

export type Koute = {
    _version: string,
    Route: (string) -> ((RouteParams) -> Route),
    Meta: (string) -> (Fusion.Symbol),
    Router: (RouterParams) -> (Router),
    Canvas: ({ Source: Router }) -> ( Frame ),
}

return {}
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100010672</UniqueId>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="Folder" referent="RBX5D29A52B2D1945B796AA8DFC137B18DB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
						<bool name="DefinesCapabilities">false</bool>
						<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
						<string name="Name">elttob_fusion@0.1.1-beta</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<UniqueId name="UniqueId">35e96ac358fec8160612c78100010673</UniqueId>
					</Properties>
					<Item class="ModuleScript" referent="RBXE998452D0B3C46F8A6E2A10B7FC5BCBC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
							<bool name="DefinesCapabilities">false</bool>
							<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">fusion</string>
							<string name="ScriptGuid">{D0C595BA-D70C-46CC-901C-6E1099FA2AAF}</string>
							<ProtectedString name="Source"><![CDATA[--[[
	The entry point for the Fusion library.
]]

local Types = require(script.Types)
local restrictRead = require(script.Utility.restrictRead)

export type State = Types.State
export type StateOrValue = Types.StateOrValue
export type Symbol = Types.Symbol

return restrictRead("Fusion", {
	New = require(script.Instances.New),
	Children = require(script.Instances.Children),
	OnEvent = require(script.Instances.OnEvent),
	OnChange = require(script.Instances.OnChange),

	State = require(script.State.State),
	Computed = require(script.State.Computed),
	ComputedPairs = require(script.State.ComputedPairs),
	Compat = require(script.State.Compat),

	Tween = require(script.Animation.Tween),
	Spring = require(script.Animation.Spring)
})]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UniqueId name="UniqueId">35e96ac358fec8160612c78100010674</UniqueId>
						</Properties>
						<Item class="Folder" referent="RBXAB319CBEB1F54D479E5568D6C3783AB9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Animation</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100010675</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX76AC0FA0FB0A4F30A1F19B8D7DB15C49">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Spring</string>
									<string name="ScriptGuid">{3AE183EF-036F-40CF-A9BA-2E2DB1E05CB4}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Constructs a new computed state object, which follows the value of another
	state object using a spring simulation.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)
local unpackType = require(Package.Animation.unpackType)
local SpringScheduler = require(Package.Animation.SpringScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

local ENABLE_PARAM_SETTERS = false

--[[
	Returns the current value of this Spring object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value.

	If the new goal can be animated to, the equilibrium point of the internal
	springs will be moved, but the springs themselves stay in place.
	Returns false, as this has no immediate impact on the current value of the
	Spring object.

	If the new goal can't be animated to (different types/non-animatable type),
	then the springs will be instantly moved to the goal value. Returns true, as
	the current value of the Spring object will jump directly to the goal.
]]
function class:update()
	local goalValue = self._goalState:get(false)

	local oldType = self._currentType
	local newType = typeof(goalValue)

	self._goalValue = goalValue
	self._currentType = newType

	local springGoals = unpackType(goalValue, newType)
	local numSprings = #springGoals

	self._springGoals = springGoals

	if newType ~= oldType then
		-- if the type changed, we need to set the position and velocity
		local springPositions = table.create(numSprings, 0)
		local springVelocities = table.create(numSprings, 0)

		for index, springGoal in ipairs(springGoals) do
			springPositions[index] = springGoal
		end

		self._springPositions = springPositions
		self._springVelocities = springVelocities
		self._currentValue = self._goalValue

		SpringScheduler.remove(self)
		return true

	elseif numSprings == 0 then
		-- if the type hasn't changed, but isn't animatable, just change the
		-- current value
		self._currentValue = self._goalValue

		SpringScheduler.remove(self)
		return true
	end

	SpringScheduler.add(self)
	return false
end

if ENABLE_PARAM_SETTERS then

	--[[
		Changes the damping ratio of this Spring.
	]]
	function class:setDamping(damping: number)
		if damping < 0 then
			logError("invalidSpringDamping", nil, damping)
		end

		SpringScheduler.remove(self)
		self._damping = damping
		SpringScheduler.add(self)
	end

	--[[
		Changes the angular frequency of this Spring.
	]]
	function class:setSpeed(speed: number)
		if speed < 0 then
			logError("invalidSpringSpeed", nil, speed)
		end

		SpringScheduler.remove(self)
		self._speed = speed
		SpringScheduler.add(self)
	end

	--[[
		Sets the position of the internal springs, meaning the value of this
		Spring will jump to the given value. This doesn't affect velocity.

		If the type doesn't match the current type of the spring, an error will be
		thrown.
	]]
	function class:setPosition(newValue: Types.Animatable)
		local newType = typeof(newValue)
		if newType ~= self._currentType then
			logError("springTypeMismatch", nil, newType, self._currentType)
		end

		self._springPositions = unpackType(newValue, newType)
		self._currentValue = newValue

		updateAll(self)

		SpringScheduler.add(self)
	end

	--[[
		Sets the velocity of the internal springs, overwriting the existing velocity
		of this Spring. This doesn't affect position.

		If the type doesn't match the current type of the spring, an error will be
		thrown.
	]]
	function class:setVelocity(newValue: Types.Animatable)
		local newType = typeof(newValue)
		if newType ~= self._currentType then
			logError("springTypeMismatch", nil, newType, self._currentType)
		end

		self._springVelocities = unpackType(newValue, newType)
		SpringScheduler.add(self)
	end

	--[[
		Adds to the velocity of the internal springs, on top of the existing
		velocity of this Spring. This doesn't affect position.

		If the type doesn't match the current type of the spring, an error will be
		thrown.
	]]
	function class:addVelocity(deltaValue: Types.Animatable)
		local deltaType = typeof(deltaValue)
		if deltaType ~= self._currentType then
			logError("springTypeMismatch", nil, deltaType, self._currentType)
		end

		local springDeltas = unpackType(deltaValue, deltaType)
		for index, delta in ipairs(springDeltas) do
			self._springVelocities[index] += delta
		end

		SpringScheduler.add(self)
	end

end

local function Spring(goalState: Types.State<Types.Animatable>, speed: number?, damping: number?)
	-- check and apply defaults for speed and damping
	if speed == nil then
		speed = 10
	elseif speed < 0 then
		logError("invalidSpringSpeed", nil, speed)
	end

	if damping == nil then
		damping = 1
	elseif damping < 0 then
		logError("invalidSpringDamping", nil, damping)
	end

	local self = setmetatable({
		type = "State",
		kind = "Spring",
		dependencySet = {[goalState] = true},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_speed = speed,
		_damping = damping,

		_goalState = goalState,
		_goalValue = nil,

		_currentType = nil,
		_currentValue = nil,

		_springPositions = nil,
		_springGoals = nil,
		_springVelocities = nil
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true
	self:update()

	return self
end

return Spring]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010676</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXAA12D7BFD63B43FE945C18874BC6B341">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SpringScheduler</string>
									<string name="ScriptGuid">{481F25B3-FF48-4ED2-A604-42B783BE37AE}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Manages batch updating of spring objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local packType = require(Package.Animation.packType)
local springCoefficients = require(Package.Animation.springCoefficients)
local updateAll = require(Package.Dependencies.updateAll)

local SpringScheduler = {}

type Spring = {
	_speed: number,
	_damping: number,

	_springPositions: {number},
	_springGoals: {number},
	_springVelocities: {number}
}

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- when a spring has displacement and velocity below +/- epsilon, the spring
-- won't send updates
local MOVEMENT_EPSILON = 0.0001

-- organises springs by speed and damping, for batch processing
local springBuckets: {[number]: {[number]: Types.Set<Spring>}} = {}

--[[
	Adds a Spring to be updated every render step.
]]
function SpringScheduler.add(spring: Spring)
	local damping = spring._damping
	local speed = spring._speed

	local dampingBucket = springBuckets[damping]

	if dampingBucket == nil then
		springBuckets[damping] = {
			[speed] = setmetatable({[spring] = true}, WEAK_KEYS_METATABLE)
		}
		return
	end

	local speedBucket = dampingBucket[speed]

	if speedBucket == nil then
		dampingBucket[speed] = setmetatable({[spring] = true}, WEAK_KEYS_METATABLE)
		return
	end

	speedBucket[spring] = true
end

--[[
	Removes a Spring from the scheduler.
]]
function SpringScheduler.remove(spring: Spring)
	local damping = spring._damping
	local speed = spring._speed

	local dampingBucket = springBuckets[damping]

	if dampingBucket == nil then
		return
	end

	local speedBucket = dampingBucket[speed]

	if speedBucket == nil then
		return
	end

	speedBucket[spring] = nil
end

--[[
	Updates all Spring objects.
]]
local function updateAllSprings(timeStep: number)
	for damping, dampingBucket in pairs(springBuckets) do
		for speed, speedBucket in pairs(dampingBucket) do
			local posPosCoef, posVelCoef, velPosCoef, velVelCoef = springCoefficients(timeStep, damping, speed)

			for spring in pairs(speedBucket) do
				local goals = spring._springGoals
				local positions = spring._springPositions
				local velocities = spring._springVelocities

				local isMoving = false

				for index, goal in ipairs(goals) do
					local oldPosition = positions[index]
					local oldVelocity = velocities[index]

					local oldDisplacement = oldPosition - goal

					local newDisplacement = oldDisplacement * posPosCoef + oldVelocity * posVelCoef
					local newVelocity = oldDisplacement * velPosCoef + oldVelocity * velVelCoef

					if
						math.abs(newDisplacement) > MOVEMENT_EPSILON or
						math.abs(newVelocity) > MOVEMENT_EPSILON
					then
						isMoving = true
					end

					positions[index] = newDisplacement + goal
					velocities[index] = newVelocity
				end

				-- if the spring moved a significant distance, update its
				-- current value, otherwise stop animating
				if isMoving then
					spring._currentValue = packType(positions, spring._currentType)
					updateAll(spring)
				else
					SpringScheduler.remove(spring)
				end
			end
		end
	end
end

RunService:BindToRenderStep(
	"__FusionSpringScheduler",
	Enum.RenderPriority.First.Value,
	updateAllSprings
)

return SpringScheduler]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010677</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6C45C7AF105243A1A8436E709745112B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Tween</string>
									<string name="ScriptGuid">{3AAAEF8E-A0EF-4686-A774-B46C02950E70}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Constructs a new computed state object, which follows the value of another
	state object using a tween.
]]

local Package = script.Parent.Parent
local TweenScheduler = require(Package.Animation.TweenScheduler)
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

local ENABLE_PARAM_SETTERS = false

--[[
	Returns the current value of this Tween object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._currentValue
end

--[[
	Called when the goal state changes value; this will initiate a new tween.
	Returns false as the current value doesn't change right away.
]]
function class:update()
	self._prevValue = self._currentValue
	self._nextValue = self._goalState:get(false)

	self._currentTweenStartTime = os.clock()
	self._currentTweenInfo = self._tweenInfo

	local tweenDuration = self._tweenInfo.DelayTime + self._tweenInfo.Time
	if self._tweenInfo.Reverses then
		tweenDuration += self._tweenInfo.Time
	end
	tweenDuration *= self._tweenInfo.RepeatCount
	self._currentTweenDuration = tweenDuration

	-- start animating this tween
	TweenScheduler.add(self)
	return false
end

if ENABLE_PARAM_SETTERS then

	--[[
		Specifies a new TweenInfo to use when the goal state changes in the future.
	]]
	function class:setTweenInfo(newTweenInfo: TweenInfo)
		self._tweenInfo = newTweenInfo
	end

end

local function Tween(goalState: Types.State<Types.Animatable>, tweenInfo: TweenInfo?)
	local currentValue = goalState:get(false)

	local self = setmetatable({
		type = "State",
		kind = "Tween",
		dependencySet = {[goalState] = true},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_goalState = goalState,
		_tweenInfo = tweenInfo or TweenInfo.new(),

		_prevValue = currentValue,
		_nextValue = currentValue,
		_currentValue = currentValue,

		-- store current tween into separately from 'real' tween into, so it
		-- isn't affected by :setTweenInfo() until next change
		_currentTweenInfo = tweenInfo,
		_currentTweenDuration = 0,
		_currentTweenStartTime = 0
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the goal state's dependent set
	goalState.dependentSet[self] = true

	return self
end

return Tween]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010678</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF3B561AAD7844016973D5AFF9A9DC077">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">TweenScheduler</string>
									<string name="ScriptGuid">{26410692-05C1-4328-8D6C-5ABFFC79A015}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Manages batch updating of tween objects.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local lerpType = require(Package.Animation.lerpType)
local getTweenRatio = require(Package.Animation.getTweenRatio)
local updateAll = require(Package.Dependencies.updateAll)

local TweenScheduler = {}

type Tween = {
	_prevValue: Types.Animatable,
	_nextValue: Types.Animatable,
	_currentValue: Types.Animatable,

	_tweenStartTime: number,
	_tweenDuration: number,
	_tweenInfo: TweenInfo
}

local WEAK_KEYS_METATABLE = {__mode = "k"}

-- all the tweens currently being updated
local allTweens: Types.Set<Tween> = setmetatable({}, WEAK_KEYS_METATABLE)

--[[
	Adds a Tween to be updated every render step.
]]
function TweenScheduler.add(tween: Tween)
	allTweens[tween] = true
end

--[[
	Removes a Tween from the scheduler.
]]
function TweenScheduler.remove(tween: Tween)
	allTweens[tween] = nil
end

--[[
	Updates all Tween objects.
]]
local function updateAllTweens()
	local now = os.clock()
	for tween in pairs(allTweens) do
		local currentTime = now - tween._currentTweenStartTime

		if currentTime > tween._currentTweenDuration then
			if tween._currentTweenInfo.Reverses then
				tween._currentValue = tween._prevValue
			else
				tween._currentValue = tween._nextValue
			end
			updateAll(tween)
			TweenScheduler.remove(tween)
		else
			local ratio = getTweenRatio(tween._currentTweenInfo, currentTime)
			local currentValue = lerpType(tween._prevValue, tween._nextValue, ratio)
			tween._currentValue = currentValue
			updateAll(tween)
		end
	end
end

RunService:BindToRenderStep(
	"__FusionTweenScheduler",
	Enum.RenderPriority.First.Value,
	updateAllTweens
)

return TweenScheduler]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010679</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX47C3803A64BA46E0BC4CD9E4AFBFCA24">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">getTweenRatio</string>
									<string name="ScriptGuid">{2732A8CF-E8D4-4993-A131-496B23187FC3}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Given a `tweenInfo` and `currentTime`, returns a ratio which can be used to
	tween between two values over time.
]]

local TweenService = game:GetService("TweenService")

local function getTweenRatio(tweenInfo: TweenInfo, currentTime: number): number
	local delay = tweenInfo.DelayTime
	local duration = tweenInfo.Time
	local reverses = tweenInfo.Reverses
	local numRepeats = tweenInfo.RepeatCount
	local easeStyle = tweenInfo.EasingStyle
	local easeDirection = tweenInfo.EasingDirection

	local cycleDuration = delay + duration
	if reverses then
		cycleDuration += duration
	end

	if currentTime >= cycleDuration * numRepeats then
		return 1
	end

	local cycleTime = currentTime % cycleDuration

	if cycleTime <= delay then
		return 0
	end

	local tweenProgress = (cycleTime - delay) / duration
	if tweenProgress > 1 then
		tweenProgress = 2 - tweenProgress
	end

	local ratio = TweenService:GetValue(tweenProgress, easeStyle, easeDirection)
	return ratio
end

return getTweenRatio]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001067a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXBE227E5111B949BD8216D564C6A86F90">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">lerpType</string>
									<string name="ScriptGuid">{D732872C-DE27-4381-8E28-B260D02D66FA}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Linearly interpolates the given animatable types by a ratio.
	If the types are different or not animatable, then the first value will be
	returned for ratios below 0.5, and the second value for 0.5 and above.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local Oklab = require(Package.Colour.Oklab)

local function lerpType(from: Types.Animatable | any, to: Types.Animatable | any, ratio: number): Types.Animatable | any
	local typeString = typeof(from)

	if typeof(to) == typeString then
		-- both types must match for interpolation to make sense
		if typeString == "number" then
			return (to - from) * ratio + from

		elseif typeString == "CFrame" then
			return from:Lerp(to, ratio)

		elseif typeString == "Color3" then
			local fromLab = Oklab.to(from)
			local toLab = Oklab.to(to)
			return Oklab.from(
				fromLab:Lerp(toLab, ratio),
				false
			)

		elseif typeString == "ColorSequenceKeypoint" then
			local fromLab = Oklab.to(from.Value)
			local toLab = Oklab.to(to.Value)
			return ColorSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				Oklab.from(
					fromLab:Lerp(toLab, ratio),
					false
				)
			)

		elseif typeString == "DateTime" then
			return DateTime.fromUnixTimestampMillis(
				(to.UnixTimestampMillis - from.UnixTimestampMillis) * ratio + from.UnixTimestampMillis
			)

		elseif typeString == "NumberRange" then
			return NumberRange.new(
				(to.Min - from.Min) * ratio + from.Min,
				(to.Max - from.Max) * ratio + from.Max
			)

		elseif typeString == "NumberSequenceKeypoint" then
			return NumberSequenceKeypoint.new(
				(to.Time - from.Time) * ratio + from.Time,
				(to.Value - from.Value) * ratio + from.Value,
				(to.Envelope - from.Envelope) * ratio + from.Envelope
			)

		elseif typeString == "PhysicalProperties" then
			return PhysicalProperties.new(
				(to.Density - from.Density) * ratio + from.Density,
				(to.Friction - from.Friction) * ratio + from.Friction,
				(to.Elasticity - from.Elasticity) * ratio + from.Elasticity,
				(to.FrictionWeight - from.FrictionWeight) * ratio + from.FrictionWeight,
				(to.ElasticityWeight - from.ElasticityWeight) * ratio + from.ElasticityWeight
			)

		elseif typeString == "Ray" then
			return Ray.new(
				from.Origin:Lerp(to.Origin, ratio),
				from.Direction:Lerp(to.Direction, ratio).Unit *
				(to.Direction.Magnitude - from.Direction.Magnitude) * ratio + from.Direction.Magnitude
			)

		elseif typeString == "Rect" then
			return Rect.new(
				from.Min:Lerp(to.Min, ratio),
				from.Max:Lerp(to.Max, ratio)
			)

		elseif typeString == "Region3" then
			-- FUTURE: support rotated Region3s if/when they become constructable
			local position = from.CFrame.Position:Lerp(to.CFrame.Position, ratio)
			local halfSize = from.Size:Lerp(to.Size, ratio) / 2
			return Region3.new(position - halfSize, position + halfSize)

		elseif typeString == "Region3int16" then
			return Region3int16.new(
				Vector3int16.new(
					(to.Min.X - from.Min.X) * ratio + from.Min.X,
					(to.Min.Y - from.Min.Y) * ratio + from.Min.Y,
					(to.Min.Z - from.Min.Z) * ratio + from.Min.Z
				),
				Vector3int16.new(
					(to.Max.X - from.Max.X) * ratio + from.Max.X,
					(to.Max.Y - from.Max.Y) * ratio + from.Max.Y,
					(to.Max.Z - from.Max.Z) * ratio + from.Max.Z
				)
			)

		elseif typeString == "UDim" then
			return UDim.new(
				(to.Scale - from.Scale) * ratio + from.Scale,
				(to.Offset - from.Offset) * ratio + from.Offset
			)

		elseif typeString == "UDim2" then
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2" then
			return from:Lerp(to, ratio)

		elseif typeString == "Vector2int16" then
			return Vector2int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y
			)

		elseif typeString == "Vector3" then
			return from:Lerp(to, ratio)

		elseif typeString == "Vector3int16" then
			return Vector3int16.new(
				(to.X - from.X) * ratio + from.X,
				(to.Y - from.Y) * ratio + from.Y,
				(to.Z - from.Z) * ratio + from.Z
			)
		end
	end

	-- fallback case: the types are different or not animatable
	if ratio < 0.5 then
		return from
	else
		return to
	end
end

return lerpType]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001067b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4B1A1C47FF444BD4B3B545F7A24661EA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">packType</string>
									<string name="ScriptGuid">{7B7D5260-369C-43F1-AEE7-3C438E9A1262}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Packs an array of numbers into a given animatable data type.
	If the type is not animatable, nil will be returned.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local Oklab = require(Package.Colour.Oklab)

local function packType(numbers: {number}, typeString: string): Types.Animatable
	if typeString == "number" then
		return numbers[1]

	elseif typeString == "CFrame" then
		return
			CFrame.new(numbers[1], numbers[2], numbers[3]) *
			CFrame.fromAxisAngle(
				Vector3.new(numbers[4], numbers[5], numbers[6]).Unit,
				numbers[7]
			)

	elseif typeString == "Color3" then
		return Oklab.from(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			false
		)

	elseif typeString == "ColorSequenceKeypoint" then
		return ColorSequenceKeypoint.new(
			numbers[4],
			Oklab.from(
				Vector3.new(numbers[1], numbers[2], numbers[3]),
				false
			)
		)

	elseif typeString == "DateTime" then
		return DateTime.fromUnixTimestampMillis(numbers[1])

	elseif typeString == "NumberRange" then
		return NumberRange.new(numbers[1], numbers[2])

	elseif typeString == "NumberSequenceKeypoint" then
		return NumberSequenceKeypoint.new(numbers[2], numbers[1], numbers[3])

	elseif typeString == "PhysicalProperties" then
		return PhysicalProperties.new(numbers[1], numbers[2], numbers[3], numbers[4], numbers[5])

	elseif typeString == "Ray" then
		return Ray.new(
			Vector3.new(numbers[1], numbers[2], numbers[3]),
			Vector3.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "Rect" then
		return Rect.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		local position = Vector3.new(numbers[1], numbers[2], numbers[3])
		local halfSize = Vector3.new(numbers[4] / 2, numbers[5] / 2, numbers[6] / 2)
		return Region3.new(position - halfSize, position + halfSize)

	elseif typeString == "Region3int16" then
		return Region3int16.new(
			Vector3int16.new(numbers[1], numbers[2], numbers[3]),
			Vector3int16.new(numbers[4], numbers[5], numbers[6])
		)

	elseif typeString == "UDim" then
		return UDim.new(numbers[1], numbers[2])

	elseif typeString == "UDim2" then
		return UDim2.new(numbers[1], numbers[2], numbers[3], numbers[4])

	elseif typeString == "Vector2" then
		return Vector2.new(numbers[1], numbers[2])

	elseif typeString == "Vector2int16" then
		return Vector2int16.new(numbers[1], numbers[2])

	elseif typeString == "Vector3" then
		return Vector3.new(numbers[1], numbers[2], numbers[3])

	elseif typeString == "Vector3int16" then
		return Vector3int16.new(numbers[1], numbers[2], numbers[3])
	end
end

return packType]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001067c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX38262989789F4CDE852AE4276E56A72A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">springCoefficients</string>
									<string name="ScriptGuid">{7891268F-62EC-4B05-A094-C9D3B3EAC44B}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Returns a 2x2 matrix of coefficients for a given damping ratio, speed and
	time step. These coefficients can then be multiplied with the position and
	velocity of an existing spring to find the new position and velocity values.

	Specifically, this function returns four numbers -  posPos, posVel, velPos,
	and velVel, in that order - which can be applied to position and velocity
	like so:

	local newPosition = oldPosition * posPos + oldVelocity * posVel
	local newVelocity = oldPosition * velPos + oldVelocity * velVel

	If a large number of springs with identical damping ratios and speeds are
	being updated with the same time step, then these coefficients can be used
	to update all of them at once.

	This function assumes the damping ratio, speed and time step are all >= 0,
	with the expectation that these values have been verified beforehand.
]]

local function springCoefficients(timeStep: number, damping: number, speed: number): (number, number, number, number)
	-- if time step or speed is 0, then the spring won't move, so an identity
	-- matrix can be returned early
	if timeStep == 0 or speed == 0 then
		return
			1, 0,
			0, 1
	end

	if damping > 1 then
		-- overdamped spring

		-- solutions to the characteristic equation
		-- z = -  Sqrt[^2 - 1] 

		local zRoot = math.sqrt(damping^2 - 1)

		local z1 = (-zRoot - damping)*speed
		local z2 = (zRoot - damping)*speed

		-- x[t] -> x0(e^(t z2) z1 - e^(t z1) z2)/(z1 - z2)
		--		 + v0(e^(t z1) - e^(t z2))/(z1 - z2)

		local zDivide = 1/(z1 - z2)

		local z1Exp = math.exp(timeStep * z1)
		local z2Exp = math.exp(timeStep * z2)

		local posPosCoef = (z2Exp * z1 - z1Exp * z2) * zDivide
		local posVelCoef = (z1Exp - z2Exp) * zDivide

		-- v[t] -> x0(z1 z2(-e^(t z1) + e^(t z2)))/(z1 - z2)
		--		 + v0(z1 e^(t z1) - z2 e^(t z2))/(z1 - z2)

		local velPosCoef = z1*z2 * (-z1Exp + z2Exp) * zDivide
		local velVelCoef = (z1*z1Exp - z2*z2Exp) * zDivide

		return
			posPosCoef, posVelCoef,
			velPosCoef, velVelCoef

	elseif damping == 1 then
		-- critically damped spring

		-- x[t] -> x0(e^-t)(1+t) + v0(e^-t)t

		local timeStepSpeed = timeStep * speed
		local negSpeedExp = math.exp(-timeStepSpeed)

		local posPosCoef = negSpeedExp * (1 + timeStepSpeed)
		local posVelCoef = negSpeedExp * timeStep

		-- v[t] -> x0(t ^2)(-e^-t) + v0(1 - t)(e^-t)

		local velPosCoef = -negSpeedExp * (timeStep * speed*speed)
		local velVelCoef = negSpeedExp * (1 - timeStepSpeed)

		return
			posPosCoef, posVelCoef,
			velPosCoef, velVelCoef

	else
		-- underdamped spring

		-- factored out of the solutions to the characteristic equation, to make
		-- the math cleaner

		local alpha = math.sqrt(1 - damping^2) * speed

		-- x[t] -> x0(e^-t)( Cos[t] +  Sin[t])/
		--       + v0(e^-t)(Sin[t])/

		local negDampSpeedExp = math.exp(-timeStep * damping * speed)

		local sinAlpha = math.sin(timeStep*alpha)
		local alphaCosAlpha = alpha * math.cos(timeStep*alpha)
		local dampSpeedSinAlpha = damping*speed*sinAlpha

		local invAlpha = 1 / alpha

		local posPosCoef = negDampSpeedExp * (alphaCosAlpha + dampSpeedSinAlpha) * invAlpha
		local posVelCoef = negDampSpeedExp * sinAlpha * invAlpha

		-- v[t] -> x0(-e^-t)(^2 + ^2 ^2)(Sin[t])/
		--       + v0(e^-t)( Cos[t] -  Sin[t])/

		local velPosCoef = -negDampSpeedExp * (alpha*alpha + damping*damping * speed*speed) * sinAlpha * invAlpha
		local velVelCoef = negDampSpeedExp * (alphaCosAlpha - dampSpeedSinAlpha) * invAlpha

		return
			posPosCoef, posVelCoef,
			velPosCoef, velVelCoef
	end
end

return springCoefficients]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001067d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9756C8DEE96E4762B79C2E0D0289900B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">unpackType</string>
									<string name="ScriptGuid">{BB5269DB-D9DF-485C-9428-DCBA7964EEDC}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Unpacks an animatable type into an array of numbers.
	If the type is not animatable, an empty array will be returned.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local Oklab = require(Package.Colour.Oklab)

local function unpackType(value: Types.Animatable, typeString: string): {number}
	if typeString == "number" then
		return {value}

	elseif typeString == "CFrame" then
		-- FUTURE: is there a better way of doing this? doing distance
		-- calculations on `angle` may be incorrect
		local axis, angle = value:ToAxisAngle()
		return {value.X, value.Y, value.Z, axis.X, axis.Y, axis.Z, angle}

	elseif typeString == "Color3" then
		local lab = Oklab.to(value)
		return {lab.X, lab.Y, lab.Z}

	elseif typeString == "ColorSequenceKeypoint" then
		local lab = Oklab.to(value.Value)
		return {lab.X, lab.Y, lab.Z, value.Time}

	elseif typeString == "DateTime" then
		return {value.UnixTimestampMillis}

	elseif typeString == "NumberRange" then
		return {value.Min, value.Max}

	elseif typeString == "NumberSequenceKeypoint" then
		return {value.Value, value.Time, value.Envelope}

	elseif typeString == "PhysicalProperties" then
		return {value.Density, value.Friction, value.Elasticity, value.FrictionWeight, value.ElasticityWeight}

	elseif typeString == "Ray" then
		return {value.Origin.X, value.Origin.Y, value.Origin.Z, value.Direction.X, value.Direction.Y, value.Direction.Z}

	elseif typeString == "Rect" then
		return {value.Min.X, value.Min.Y, value.Max.X, value.Max.Y}

	elseif typeString == "Region3" then
		-- FUTURE: support rotated Region3s if/when they become constructable
		return {
			value.CFrame.X, value.CFrame.Y, value.CFrame.Z,
			value.Size.X, value.Size.Y, value.Size.Z
		}

	elseif typeString == "Region3int16" then
		return {value.Min.X, value.Min.Y, value.Min.Z, value.Max.X, value.Max.Y, value.Max.Z}

	elseif typeString == "UDim" then
		return {value.Scale, value.Offset}

	elseif typeString == "UDim2" then
		return {value.X.Scale, value.X.Offset, value.Y.Scale, value.Y.Offset}

	elseif typeString == "Vector2" then
		return {value.X, value.Y}

	elseif typeString == "Vector2int16" then
		return {value.X, value.Y}

	elseif typeString == "Vector3" then
		return {value.X, value.Y, value.Z}

	elseif typeString == "Vector3int16" then
		return {value.X, value.Y, value.Z}
	else
		return {}
	end
end

return unpackType]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001067e</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX0E2C6F9FD4C04C6C8BF82270F7282AC4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Colour</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c7810001067f</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX981772611CEC4DDAA3118C20E052470C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Oklab</string>
									<string name="ScriptGuid">{24495C40-6190-48A5-AF41-A84ABA1A8E2B}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Provides functions for converting Color3s into Oklab space, for more
	perceptually uniform colour blending.

	See: https://bottosson.github.io/posts/oklab/
]]

local Oklab = {}

-- Converts a Color3 in RGB space to a Vector3 in Oklab space.
function Oklab.to(rgb: Color3): Vector3
	local l = rgb.R * 0.4122214708 + rgb.G * 0.5363325363 + rgb.B * 0.0514459929
	local m = rgb.R * 0.2119034982 + rgb.G * 0.6806995451 + rgb.B * 0.1073969566
	local s = rgb.R * 0.0883024619 + rgb.G * 0.2817188376 + rgb.B * 0.6299787005

    local lRoot = l ^ (1/3)
    local mRoot = m ^ (1/3)
    local sRoot = s ^ (1/3)

    return Vector3.new(
        lRoot * 0.2104542553 + mRoot * 0.7936177850 - sRoot * 0.0040720468,
        lRoot * 1.9779984951 - mRoot * 2.4285922050 + sRoot * 0.4505937099,
        lRoot * 0.0259040371 + mRoot * 0.7827717662 - sRoot * 0.8086757660
	)
end

-- Converts a Vector3 in CIELAB space to a Color3 in RGB space.
-- The Color3 will be clamped by default unless specified otherwise.
function Oklab.from(lab: Vector3, unclamped: boolean?): Color3
	local lRoot = lab.X + lab.Y * 0.3963377774 + lab.Z * 0.2158037573
    local mRoot = lab.X - lab.Y * 0.1055613458 - lab.Z * 0.0638541728
    local sRoot = lab.X - lab.Y * 0.0894841775 - lab.Z * 1.2914855480

    local l = lRoot ^ 3
    local m = mRoot ^ 3
    local s = sRoot ^ 3

	local red = l * 4.0767416621 - m * 3.3077115913 + s * 0.2309699292
	local green = l * -1.2684380046 + m * 2.6097574011 - s * 0.3413193965
	local blue = l * -0.0041960863 - m * 0.7034186147 + s * 1.7076147010

	if not unclamped then
		red = math.clamp(red, 0, 1)
		green = math.clamp(green, 0, 1)
		blue = math.clamp(blue, 0, 1)
	end

	return Color3.new(red, green, blue)
end

return Oklab]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010680</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX37F4EDB72AFE4918B52150AB9FDAF08F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Dependencies</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100010681</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX8BEFAC03D37043A58A30C7AAE0B952F3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">captureDependencies</string>
									<string name="ScriptGuid">{66C7999F-E212-4ACD-AC38-F310E866A240}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Calls the given callback, and stores any used external dependencies.
	Arguments can be passed in after the callback.
	If the callback completed successfully, returns true and the returned value,
	otherwise returns false and the error thrown.
	The callback shouldn't yield or run asynchronously.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local parseError = require(Package.Logging.parseError)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack
-- counts how many sets are currently stored in `initialisedStack`, whether
-- they're currently in use or not
local initialisedStackCapacity = 0

local function captureDependencies(saveToSet: Types.Set<Types.Dependency<any>>, callback: (any) -> any, ...): (boolean, any)
	-- store whichever set was being saved to previously, and replace it with
	-- the new set which was passed in
	local prevDependencySet = sharedState.dependencySet
	sharedState.dependencySet = saveToSet

	-- Add a new 'initialised' set to the stack of initialised sets.
	-- If a dependency is created inside the callback (even if indirectly inside
	-- a different `captureDependencies` call), it'll be added to this set.
	-- This can be used to ignore dependencies that were created inside of the
	-- callback.
	sharedState.initialisedStackSize += 1
	local initialisedStackSize = sharedState.initialisedStackSize

	local initialisedSet

	-- instead of constructing new sets all of the time, we can simply leave old
	-- sets in the stack and keep track of the 'real' number of sets ourselves.
	-- this means we don't have to keep creating and throwing away tables, which
	-- is great for performance at the expense of slightly more memory usage.
	if initialisedStackSize > initialisedStackCapacity then
		-- the stack has grown beyond any previous size, so we need to create
		-- a new table
		initialisedSet = {}
		initialisedStack[initialisedStackSize] = initialisedSet
		initialisedStackCapacity = initialisedStackSize
	else
		-- the stack is smaller or equal to some previous size, so we just need
		-- to clear whatever set was here before
		initialisedSet = initialisedStack[initialisedStackSize]
		table.clear(initialisedSet)
	end

	-- now that the shared state has been set up, call the callback in a pcall.
	-- using a pcall means the shared state can be reset afterwards, even if an
	-- error occurs.
	local ok, value = xpcall(callback, parseError, ...)

	-- restore the previous set being saved to
	sharedState.dependencySet = prevDependencySet
	-- shrink the stack of initialised sets (essentially removing this set)
	sharedState.initialisedStackSize -= 1

	return ok, value
end

return captureDependencies]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010682</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX61913BE0C4BD490AAEAB8AFC69E596C7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">initDependency</string>
									<string name="ScriptGuid">{89C6013B-D32C-447E-A8CB-A6FB63DE48F0}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Registers the creation of an object which can be used as a dependency.

	This is used to make sure objects don't capture dependencies originating
	from inside of themselves.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function initDependency(dependency: Types.Dependency<any>)
	local initialisedStackSize = sharedState.initialisedStackSize

	for index, initialisedSet in ipairs(initialisedStack) do
		if index > initialisedStackSize then
			return
		end

		initialisedSet[dependency] = true
	end
end

return initDependency]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010683</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD9D75ED398BE4824B428D838A2021A5B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">sharedState</string>
									<string name="ScriptGuid">{5EBCCC72-91BA-471B-A87C-AD684AD534A3}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Stores shared state for dependency management functions.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

type SharedState = {
	dependencySet: Types.Set<Types.Dependency<any>>?,

	initialisedStack: {Types.Set<Types.Dependency<any>>},
	initialisedStackSize: number
}

local sharedState: SharedState = {
	-- The set where used dependencies should be saved to.
	dependencySet = nil,

	-- A stack of sets where newly created dependencies should be stored.
	initialisedStack = {},
	initialisedStackSize = 0
}

return sharedState]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010684</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX71A7A77E769E43D4A33929E19D29D929">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">updateAll</string>
									<string name="ScriptGuid">{3DF087CE-ED0C-4352-81A6-0CADCC9C85CB}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Given a reactive object, updates all dependent reactive objects.
	Objects are only ever updated after all of their dependencies are updated,
	are only ever updated once, and won't be updated if their dependencies are
	unchanged.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function updateAll(ancestor: Types.Dependency<any>)
	--[[
		First things first, we need to mark all indirect dependents as needing
		an update. This means we can ignore any dependencies that aren't related
		to the current update operation.
	]]

	-- set of all dependents that still need to be updated
	local needsUpdateSet: Types.Set<Types.Dependent<any>> = {}
	-- the dependents to be processed now
	local processNow: {Types.Dependent<any>} = {}
	local processNowSize = 0
	-- the dependents of the open set to be processed next
	local processNext: {Types.Dependent<any>} = {}
	local processNextSize = 0

	-- initialise `processNow` with dependents of ancestor
	for dependent in pairs(ancestor.dependentSet) do
		processNowSize += 1
		processNow[processNowSize] = dependent
	end

	repeat
		-- if we add to `processNext` this will be false, indicating we need to
		-- process more dependents
		local processingDone = true

		for _, member in ipairs(processNow) do
			-- mark this member as needing an update
			needsUpdateSet[member] = true

			-- add the dependents of the member for processing
			if member.dependentSet ~= nil then
				for dependent in pairs(member.dependentSet) do
					processNextSize += 1
					processNext[processNextSize] = dependent
					processingDone = false
				end
			end
		end

		-- swap in the next dependents to be processed
		processNow, processNext = processNext, processNow
		processNowSize, processNextSize = processNextSize, 0
		table.clear(processNext)
	until processingDone

	--[[
		`needsUpdateSet` is now set up. Now that we have this information, we
		can iterate over the dependents once more and update them only when the
		relevant dependencies have been updated.
	]]

	-- re-initialise `processNow` similar to before
	processNowSize = 0
	table.clear(processNow)
	for dependent in pairs(ancestor.dependentSet) do
		processNowSize += 1
		processNow[processNowSize] = dependent
	end

	repeat
		-- if we add to `processNext` this will be false, indicating we need to
		-- process more dependents
		local processingDone = true

		for _, member in ipairs(processNow) do
			-- mark this member as no longer needing an update
			needsUpdateSet[member] = nil

			--FUTURE: should this guard against errors?
			local didChange = member:update()

			-- add the dependents of the member for processing
			-- optimisation: if nothing changed, then we don't need to add these
			-- dependents, because they don't need processing.
			if didChange and member.dependentSet ~= nil then
				for dependent in pairs(member.dependentSet) do
					-- don't add dependents that have un-updated dependencies
					local allDependenciesUpdated = true
					for dependentDependency in pairs(dependent.dependencySet) do
						if needsUpdateSet[dependentDependency] then
							allDependenciesUpdated = false
							break
						end
					end

					if allDependenciesUpdated then
						processNextSize += 1
						processNext[processNextSize] = dependent
						processingDone = false
					end
				end
			end
		end

		if not processingDone then
			-- swap in the next dependents to be processed
			processNow, processNext = processNext, processNow
			processNowSize, processNextSize = processNextSize, 0
			table.clear(processNext)
		end
	until processingDone

	--[[
		The update is now complete!
	]]
end

return updateAll]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010685</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9B639F0444CA43D39BEC8B5F75B986BB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">useDependency</string>
									<string name="ScriptGuid">{A5C3E0BF-D855-471E-B9D0-0CD7D6BB3078}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	If a target set was specified by captureDependencies(), this will add the
	given dependency to the target set.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local sharedState = require(Package.Dependencies.sharedState)

local initialisedStack = sharedState.initialisedStack

local function useDependency(dependency: Types.Dependency<any>)
	local dependencySet = sharedState.dependencySet

	if dependencySet ~= nil then
		local initialisedStackSize = sharedState.initialisedStackSize
		if initialisedStackSize > 0 then
			local initialisedSet = initialisedStack[initialisedStackSize]
			if initialisedSet[dependency] ~= nil then
				return
			end
		end
		dependencySet[dependency] = true
	end
end

return useDependency]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010686</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBXE60923E87C5248558C0837CC12AFA6A0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Instances</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100010687</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBXA3F9D346E14645C3A29723933F3101DE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Children</string>
									<string name="ScriptGuid">{ABD3BEBA-9822-4FC3-A784-43A980A2D002}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	The symbol used to denote the children of an instance when working with the
	`New` function.
]]

return {
	type = "Symbol",
	name = "Children"
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010688</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX9F9693E70F7D41BD9BD607CA9F1EE683">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">New</string>
									<string name="ScriptGuid">{5D3D0660-C6CA-47E7-B3C0-801F3A5E4137}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Constructs and returns a new instance, with options for setting properties,
	event handlers and other attributes on the instance right away.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local cleanupOnDestroy = require(Package.Utility.cleanupOnDestroy)
local Children = require(Package.Instances.Children)
local Scheduler = require(Package.Instances.Scheduler)
local defaultProps = require(Package.Instances.defaultProps)
local Compat = require(Package.State.Compat)
local logError = require(Package.Logging.logError)
local logWarn = require(Package.Logging.logWarn)

local WEAK_KEYS_METATABLE = {__mode = "k"}

local ENABLE_EXPERIMENTAL_GC_MODE = false

-- NOTE: this needs to be weakly held so gc isn't inhibited
local overrideParents: {[Instance]: Types.StateOrValue<Instance>} = setmetatable({}, WEAK_KEYS_METATABLE)

local function New(className: string)
	return function(propertyTable: {[string | Types.Symbol]: any})
		-- things to clean up when the instance is destroyed or gc'd
		local cleanupTasks = {}
		-- event handlers to connect
		local toConnect: {[RBXScriptSignal]: () -> ()} = {}

		--[[
			STEP 1: Create a reference to a new instance
		]]
		local refMetatable = {__mode = ""}
		local ref = setmetatable({}, refMetatable)
		local conn

		do
			local createOK, instance = pcall(Instance.new, className)
			if not createOK then
				logError("cannotCreateClass", nil, className)
			end

			local defaultClassProps = defaultProps[className]
			if defaultClassProps ~= nil then
				for property, value in pairs(defaultClassProps) do
					instance[property] = value
				end
			end

			ref.instance = instance

			conn = instance.Changed:Connect(function() end)
			instance = nil
		end

		--[[
			STEP 2: Apply properties and event handlers
		]]
		for key, value in pairs(propertyTable) do
			-- ignore some keys which will be processed later
			if key == Children or key == "Parent" then
				continue

			--[[
				STEP 2.1: Property (string) keys
			]]
			elseif typeof(key) == "string" then

				-- Properties bound to state
				if typeof(value) == "table" and value.type == "State" then
					local assignOK = pcall(function()
						ref.instance[key] = value:get(false)
					end)

					if not assignOK then
						logError("cannotAssignProperty", nil, className, key)
					end

					table.insert(cleanupTasks,
						Compat(value):onChange(function()
							if ref.instance == nil then
								if ENABLE_EXPERIMENTAL_GC_MODE then
									if conn.Connected then
										warn("ref is nil and instance is around!!!")
									else
										print("ref is nil, but instance was destroyed")
									end
								end
								return
							end
							Scheduler.enqueueProperty(ref.instance, key, value:get(false))
						end)
					)

				-- Properties with constant values
				else
					local assignOK = pcall(function()
						ref.instance[key] = value
					end)

					if not assignOK then
						logError("cannotAssignProperty", nil, className, key)
					end
				end

			--[[
				STEP 2.2: Symbol keys
			]]
			elseif typeof(key) == "table" and key.type == "Symbol" then

				-- Event handler
				if key.name == "OnEvent" then
					local event

					if
						not pcall(function()
							event = ref.instance[key.key]
						end) or
						typeof(event) ~= "RBXScriptSignal"
					then
						logError("cannotConnectChange", nil, className, key.key)
					end

					toConnect[event] = value

				-- Property change handler
				elseif key.name == "OnChange" then
					local event

					if
						not pcall(function()
							event = ref.instance:GetPropertyChangedSignal(key.key)
						end)
					then
						logError("cannotConnectChange", nil, className, key.key)
					end

					toConnect[event] = function()
						if ref.instance == nil then
							if ENABLE_EXPERIMENTAL_GC_MODE then
								if conn.Connected then
									warn("ref is nil and instance is around!!!")
								else
									print("ref is nil, but instance was destroyed")
								end
							end
							return
						end
						value(ref.instance[key.key])
					end

				-- Unknown symbol key
				else
					logError("unrecognisedPropertyKey", nil, key.name)
				end

			-- Unknown key of arbitrary type
			else
				logError("unrecognisedPropertyKey", nil, typeof(key))
			end
		end

		--[[
			STEP 3: If provided, parent [Children] to instance
		]]
		local children = propertyTable[Children]
		if children ~= nil then
			local currentChildren = {}
			local prevChildren = {}

			local currentConnections = {}
			local prevConnections = {}

			local function updateCurrentlyParented()
				if ref.instance == nil then
					if ENABLE_EXPERIMENTAL_GC_MODE then
						if conn.Connected then
							warn("ref is nil and instance is around!!!")
						else
							print("ref is nil, but instance was destroyed")
						end
					end
					return
				end

				prevChildren, currentChildren = currentChildren, prevChildren
				prevConnections, currentConnections = currentConnections, prevConnections

				local function recursiveAddChild(child)
					local childType = typeof(child)

					if childType == "Instance" then
						-- single instance child

						currentChildren[child] = true

						-- reused or newly parented logic
						if prevChildren[child] == nil then
							if overrideParents[child] == nil then
								child.Parent = ref.instance
							end
						else
							prevChildren[child] = nil
						end

					elseif childType == "table" then
						-- could either be an array or state object

						if child.type == "State" then
							-- state object

							recursiveAddChild(child:get(false))

							-- reuse old connection change handler if possible
							local prevDisconnect = prevConnections[child]
							if prevDisconnect ~= nil then
								currentConnections[child] = prevDisconnect
								prevConnections[child] = nil
							else
								-- FUTURE: does this need to be cleaned up when
								-- the instance is destroyed at any point?
								-- If so, how?
								currentConnections[child] = Compat(child):onChange(function()
									Scheduler.enqueueCallback(updateCurrentlyParented)
								end)
							end
						else
							-- array of children
							for _, subChild in pairs(child) do
								recursiveAddChild(subChild)
							end
						end

					-- explicitly allow nils (probably inside a state object)
					elseif childType ~= "nil" then
						logWarn("unrecognisedChildType", childType)
					end
				end

				recursiveAddChild(children)

				-- clean up previous children which weren't reused
				for prevChild in pairs(prevChildren) do
					if overrideParents[prevChild] == nil then
						prevChild.Parent = nil
					end
				end

				-- clean up previous connection handlers which weren't reused
				for prevState, disconnect in pairs(prevConnections) do
					disconnect()
				end

				table.clear(prevChildren)
				table.clear(prevConnections)
			end

			updateCurrentlyParented()
		end

		--[[
			STEP 4: If provided, override the Parent of this instance
		]]
		local parent = propertyTable.Parent
		if parent ~= nil then
			overrideParents[ref.instance] = parent

			if typeof(parent) == "table" and parent.type == "State" then
				-- bind parent to state object
				local assignOK = pcall(function()
					ref.instance.Parent = parent:get(false)
				end)

				if not assignOK then
					logError("cannotAssignProperty", nil, className, "Parent")
				end

				table.insert(cleanupTasks,
					Compat(parent):onChange(function()
						if ref.instance == nil then
							if ENABLE_EXPERIMENTAL_GC_MODE then
								if conn.Connected then
									warn("ref is nil and instance is around!!!")
								else
									print("ref is nil, but instance was destroyed")
								end
							end
							return
						end
						Scheduler.enqueueProperty(ref.instance, "Parent", parent:get(false))
					end)
				)

			else
				-- constant parent assignment
				local assignOK = pcall(function()
					ref.instance.Parent = parent
				end)

				if not assignOK then
					logError("cannotAssignProperty", nil, className, "Parent")
				end
			end
		end

		--[[
			STEP 5: Connect event handlers
		]]
		for event, callback in pairs(toConnect) do
			table.insert(cleanupTasks, event:Connect(callback))
		end

		--[[
			STEP 6: Register cleanup tasks if needed
		]]
		if cleanupTasks[1] ~= nil then
			if ENABLE_EXPERIMENTAL_GC_MODE then
				-- TODO: enabling this code sometimes leads to unexpected nil references appearing
				-- it remains to be determined whether this is a bug with the instance being gc'd
				-- too early, or whether this is a by-product of cleanupOnDestroy() taking some time
				-- before detecting gc'd instances.

				-- when the instance changes ancestor, check if it's still in the
				-- data model - if not, we switch to a weak reference to allow for
				-- gc to occur, otherwise hold the reference strongly
				local function updateRefStrength()
					if game:IsAncestorOf(ref.instance) then
						setmetatable(ref, {})
					else
						setmetatable(ref, {__mode = "v"})
					end
				end

				task.defer(updateRefStrength)
				table.insert(cleanupTasks, ref.instance.AncestryChanged:Connect(updateRefStrength))
			end

			cleanupOnDestroy(ref.instance, cleanupTasks)
		end

		return ref.instance
	end
end

return New]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010689</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD148DFB0E8124E21AE37ED3D35461B0B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">OnChange</string>
									<string name="ScriptGuid">{898C9EA5-8A17-4E1E-90D8-FCCF65C1FE19}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Generates symbols used to denote property change handlers when working with
	the `New` function.
]]

local function OnChange(propertyName: string)
	return {
		type = "Symbol",
		name = "OnChange",
		key = propertyName
	}
end

return OnChange]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001068a</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXC748B3073DC04031ACDBE4008BC758AE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">OnEvent</string>
									<string name="ScriptGuid">{278A5E64-09F5-486E-A5B5-53C06721E299}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Generates symbols used to denote event handlers when working with the `New`
	function.
]]

local function OnEvent(eventName: string)
	return {
		type = "Symbol",
		name = "OnEvent",
		key = eventName
	}
end

return OnEvent]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001068b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX89B0F99ED7874A5185C4E9357EE91DEC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Scheduler</string>
									<string name="ScriptGuid">{42863A38-8B7F-4B67-85E0-A2DC2DADE0AA}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Defers and orders UI data binding updates.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local Types = require(Package.Types)
local None = require(Package.Utility.None)

local Scheduler = {}

local willUpdate = false
local propertyChanges: {[Instance]: {[string]: any}} = {}
local callbacks: Types.Set<() -> ()> = {}

--[[
	Enqueues an instance property to be updated next render step.
]]
function Scheduler.enqueueProperty(instance: Instance, propertyName: string, newValue: any)
	willUpdate = true

	-- we can't iterate over nil values of tables, so use a symbol instead
	if newValue == nil then
		newValue = None
	end

	local propertyTable = propertyChanges[instance]
	if propertyTable == nil then
		propertyChanges[instance] = {
			[propertyName] = newValue
		}
	else
		propertyTable[propertyName] = newValue
	end
end

--[[
	Enqueues a callback to be run next render step.
]]
function Scheduler.enqueueCallback(callback: TaskCallback)
	willUpdate = true
	callbacks[callback] = true
end

--[[
	Executes all enqueued tasks, and clears out the task lists ready for new
	tasks.
]]
function Scheduler.runTasks()
	-- if no tasks were enqueued, exit early
	if not willUpdate then
		return
	end

	-- execute property changes
	for instance, propertyTable in pairs(propertyChanges) do
		for property, value in pairs(propertyTable) do
			if value == None then
				value = nil
			end
			instance[property] = value
		end
	end

	-- run deferred callbacks
	for callback in pairs(callbacks) do
		callback()
	end

	willUpdate = false
	table.clear(propertyChanges)
	table.clear(callbacks)
end

RunService:BindToRenderStep(
	"__FusionUIScheduler",
	Enum.RenderPriority.Last.Value,
	Scheduler.runTasks
)

return Scheduler]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001068c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX90B6ED7A90DF4E9F8F9079B676DF8667">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">defaultProps</string>
									<string name="ScriptGuid">{506B019D-F1F4-4B1B-92CF-C9E56E198BBE}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Stores 'sensible default' properties to be applied to instances created by
	the New function.
]]

local ENABLE_SENSIBLE_DEFAULTS = true

if ENABLE_SENSIBLE_DEFAULTS then
	return {
		ScreenGui = {
			ResetOnSpawn = false,
			ZIndexBehavior = "Sibling"
		},

		BillboardGui = {
			ResetOnSpawn = false,
			ZIndexBehavior = "Sibling"
		},

		SurfaceGui = {
			ResetOnSpawn = false,
			ZIndexBehavior = "Sibling",

			SizingMode = "PixelsPerStud",
			PixelsPerStud = 50
		},

		Frame = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0
		},

		ScrollingFrame = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			ScrollBarImageColor3 = Color3.new(0, 0, 0)
		},

		TextLabel = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			Font = "SourceSans",
			Text = "",
			TextColor3 = Color3.new(0, 0, 0),
			TextSize = 14
		},

		TextButton = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			AutoButtonColor = false,

			Font = "SourceSans",
			Text = "",
			TextColor3 = Color3.new(0, 0, 0),
			TextSize = 14
		},

		TextBox = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			ClearTextOnFocus = false,

			Font = "SourceSans",
			Text = "",
			TextColor3 = Color3.new(0, 0, 0),
			TextSize = 14
		},

		ImageLabel = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0
		},

		ImageButton = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0,

			AutoButtonColor = false
		},

		ViewportFrame = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0
		},

		VideoFrame = {
			BackgroundColor3 = Color3.new(1, 1, 1),
			BorderColor3 = Color3.new(0, 0, 0),
			BorderSizePixel = 0
		}
	}
else
	return {}
end]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001068d</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX632C703337AC4563812A348A913011CF">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Logging</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c7810001068e</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX5438AC7C70174CF684204EDD88BE5B49">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">logError</string>
									<string name="ScriptGuid">{2FFF7FEF-D377-4EC6-8E77-7AC4CF43DD18}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Utility function to log a Fusion-specific error.
]]
local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logError(messageID: string, errObj: Types.Error?, ...)
	local formatString = messages[messageID]

	if formatString == nil then
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	error(errorString:gsub("\n", "\n    "), 0)
end

return logError]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001068f</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXA7392C02B47240958BC08A64966D69B7">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">logErrorNonFatal</string>
									<string name="ScriptGuid">{F62A2E64-F7E1-4823-B15B-18202B4EFC04}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Utility function to log a Fusion-specific error, without halting execution.
]]
local Package = script.Parent.Parent
local Types = require(Package.Types)
local messages = require(Package.Logging.messages)

local function logErrorNonFatal(messageID: string, errObj: Types.Error?, ...)
	local formatString = messages[messageID]

	if formatString == nil then
		messageID = "unknownMessage"
		formatString = messages[messageID]
	end

	local errorString
	if errObj == nil then
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")", ...)
	else
		formatString = formatString:gsub("ERROR_MESSAGE", errObj.message)
		errorString = string.format("[Fusion] " .. formatString .. "\n(ID: " .. messageID .. ")\n---- Stack trace ----\n" .. errObj.trace, ...)
	end

	task.spawn(function(...)
		error(errorString:gsub("\n", "\n    "), 0)
	end, ...)
end

return logErrorNonFatal]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010690</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6BC6A3BA7E264ABB9B9EB022AF8A5510">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">logWarn</string>
									<string name="ScriptGuid">{D5D3DB68-0EFD-4D37-BCCE-5F3491EFF4AF}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Utility function to log a Fusion-specific warning.
]]

local Package = script.Parent.Parent
local messages = require(Package.Logging.messages)

local function logWarn(template, ...)
	local formatString = messages[template]

	if formatString == nil then
		template = "unknownMessage"
		formatString = messages[template]
	end

	warn(string.format("[Fusion] " .. formatString .. "\n(ID: " .. template .. ")", ...))
end

return logWarn]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010691</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD2D227A9506D498E84764035085E966D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">messages</string>
									<string name="ScriptGuid">{F159EC11-9562-4858-9FE4-948ACDF7B887}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Stores templates for different kinds of logging messages.
]]

return {
	cannotAssignProperty = "The class type '%s' has no assignable property '%s'.",
	cannotConnectChange = "The %s class doesn't have a property called '%s'.",
	cannotConnectEvent = "The %s class doesn't have an event called '%s'.",
	cannotCreateClass = "Can't create a new instance of class '%s'.",
	computedCallbackError = "Computed callback error: ERROR_MESSAGE",
	invalidSpringDamping = "The damping ratio for a spring must be >= 0. (damping was %.2f)",
	invalidSpringSpeed = "The speed of a spring must be >= 0. (speed was %.2f)",
	pairsDestructorError = "ComputedPairs destructor error: ERROR_MESSAGE",
	pairsProcessorError = "ComputedPairs callback error: ERROR_MESSAGE",
	springTypeMismatch = "The type '%s' doesn't match the spring's type '%s'.",
	strictReadError = "'%s' is not a valid member of '%s'.",
	unknownMessage = "Unknown error: ERROR_MESSAGE",
	unrecognisedChildType = "'%s' type children aren't accepted as children in `New`.",
	unrecognisedPropertyKey = "'%s' keys aren't accepted in the property table of `New`"
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010692</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXDEF2FD77E4734A7FA6B665F5530BCA06">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">parseError</string>
									<string name="ScriptGuid">{26A1FA2F-4CE3-4DBA-AD0F-D55496539AA0}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	An xpcall() error handler to collect and parse useful information about
	errors, such as clean messages and stack traces.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)

local function parseError(err: string): Types.Error
	return {
		raw = err,
		message = err:gsub("^.+:%d+:%s*", ""),
		trace = debug.traceback(nil, 2)
	}
end

return parseError]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010693</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX1803F1C7FCD246F9BB7C7EB07A4A9E9E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">State</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100010694</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX78EC20DEA16A46569FBAB7743E6A6EB4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Compat</string>
									<string name="ScriptGuid">{60407641-BC43-4112-8C02-475807B5C4AE}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Constructs a new state object, which exposes compatibility APIs for
	integrating with non-reactive code.
]]

local Package = script.Parent.Parent
local initDependency = require(Package.Dependencies.initDependency)

local class = {}
local CLASS_METATABLE = {__index = class}

-- Table used to hold Compat objects in memory.
local strongRefs = {}

--[[
	Called when the watched state changes value.
]]
function class:update()
	for callback in pairs(self._changeListeners) do
		coroutine.wrap(callback)()
	end
	return false
end

--[[
	Adds a change listener. When the watched state changes value, the listener
	will be fired.

	Returns a function which, when called, will disconnect the change listener.
	As long as there is at least one active change listener, this Compat object
	will be held in memory, preventing GC, so disconnecting is important.
]]
function class:onChange(callback: () -> ())
	self._numChangeListeners += 1
	self._changeListeners[callback] = true

	-- disallow gc (this is important to make sure changes are received)
	strongRefs[self] = true

	local disconnected = false
	return function()
		if disconnected then
			return
		end
		disconnected = true
		self._changeListeners[callback] = nil
		self._numChangeListeners -= 1

		if self._numChangeListeners == 0 then
			-- allow gc if all listeners are disconnected
			strongRefs[self] = nil
		end
	end
end

local function Compat(watchedState: Types.State<any>)
	local self = setmetatable({
		type = "State",
		kind = "Compat",
		dependencySet = {[watchedState] = true},
		dependentSet = {},
		_changeListeners = {},
		_numChangeListeners = 0
	}, CLASS_METATABLE)

	initDependency(self)
	-- add this object to the watched state's dependent set
	watchedState.dependentSet[self] = true

	return self
end

return Compat]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010695</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX4702D77A629449F6ACAC84836DF2D2B0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Computed</string>
									<string name="ScriptGuid">{58140392-049E-43F0-8801-215D89C5D752}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Constructs and returns objects which can be used to model derived reactive
	state.
]]

local Package = script.Parent.Parent
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the last cached value calculated by this Computed object.
	The computed object will be registered as a dependency unless `asDependency`
	is false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Recalculates this Computed's cached value and dependencies.
	Returns true if it changed, or false if it's identical.
]]
function class:update()
	-- remove this object from its dependencies' dependent sets
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end

	-- we need to create a new, empty dependency set to capture dependencies
	-- into, but in case there's an error, we want to restore our old set of
	-- dependencies. by using this table-swapping solution, we can avoid the
	-- overhead of allocating new tables each update.
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	local ok, newValue = captureDependencies(self.dependencySet, self._callback)

	if ok then
		local oldValue = self._value
		self._value = newValue

		-- add this object to the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return oldValue ~= newValue
	else
		-- this needs to be non-fatal, because otherwise it'd disrupt the
		-- update process
		logErrorNonFatal("computedCallbackError", newValue)

		-- restore old dependencies, because the new dependencies may be corrupt
		self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet

		-- restore this object in the dependencies' dependent sets
		for dependency in pairs(self.dependencySet) do
			dependency.dependentSet[self] = true
		end

		return false
	end
end

local function Computed(callback: () -> any)
	local self = setmetatable({
		type = "State",
		kind = "Computed",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},
		_callback = callback,
		_value = nil,
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return Computed]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010696</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXF95BB2BC11C3437D9C83E2D7DF1C2C21">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">ComputedPairs</string>
									<string name="ScriptGuid">{D3440A02-EAB7-43D3-B095-4D59211AFE93}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Constructs a new computed state object which maps pairs of an array using
	a `processor` function.

	Optionally, a `destructor` function can be specified for cleaning up values.
	If omitted, the default cleanup function will be used instead.
]]

local Package = script.Parent.Parent
local Types = require(Package.Types)
local captureDependencies = require(Package.Dependencies.captureDependencies)
local initDependency = require(Package.Dependencies.initDependency)
local useDependency = require(Package.Dependencies.useDependency)
local parseError = require(Package.Logging.parseError)
local logErrorNonFatal = require(Package.Logging.logErrorNonFatal)
local cleanup = require(Package.Utility.cleanup)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the current value of this ComputedPairs object.
	The object will be registered as a dependency unless `asDependency` is false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._outputTable
end

--[[
	Called when the original table is changed.

	This will firstly find any keys meeting any of the following criteria:

	- they were not previously present
	- their associated value has changed
	- a dependency used during generation of this value has changed

	It will recalculate those key/value pairs, storing information about any
	dependencies used in the processor callback during value generation, and
	save the new value to the output array. If it is overwriting an older value,
	that older value will be passed to the destructor for cleanup.

	Finally, this function will find keys that are no longer present, and remove
	their values from the output table and pass them to the destructor.

]]
function class:update()
	local inputIsState = self._inputIsState
	local oldInput = self._oldInputTable
	local newInput = self._inputTable
	local oldOutput = self._oldOutputTable
	local newOutput = self._outputTable

	if inputIsState then
		newInput = newInput:get(false)
	end

	local didChange = false

	-- clean out main dependency set
	for dependency in pairs(self.dependencySet) do
		dependency.dependentSet[self] = nil
	end
	self._oldDependencySet, self.dependencySet = self.dependencySet, self._oldDependencySet
	table.clear(self.dependencySet)

	-- if the input table is a state object, add as dependency
	if inputIsState then
		self._inputTable.dependentSet[self] = true
		self.dependencySet[self._inputTable] = true
	end

	-- STEP 1: find keys that changed value or were not previously present

	for key, newInValue in pairs(newInput) do
		-- get or create key data
		local keyData = self._keyData[key]
		if keyData == nil then
			keyData = {
				-- we don't need strong references here - the main set does that
				-- for us, so let's not introduce unnecessary leak opportunities
				dependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				oldDependencySet = setmetatable({}, WEAK_KEYS_METATABLE),
				dependencyValues = setmetatable({}, WEAK_KEYS_METATABLE)
			}
			self._keyData[key] = keyData
		end

		-- if this value is either new or different, we should recalculate it
		local shouldRecalculate = oldInput[key] ~= newInValue

		if not shouldRecalculate then
			-- check if dependencies have changed
			for dependency, oldValue in pairs(keyData.dependencyValues) do
				-- if the dependency changed value, then this needs recalculating
				if oldValue ~= dependency:get(false) then
					shouldRecalculate = true
					break
				end
			end
		end

		-- if we should recalculate the value by this point, do that
		if shouldRecalculate then
			keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet
			table.clear(keyData.dependencySet)

			local oldOutValue = oldOutput[key]
			local processOK, newOutValue = captureDependencies(keyData.dependencySet, self._processor, key, newInValue)

			if processOK then
				-- if the calculated value has changed
				if oldOutValue ~= newOutValue then
					didChange = true

					-- clean up the old calculated value
					if oldOutValue ~= nil then
						local destructOK, err = xpcall(self._destructor, parseError, oldOutValue)
						if not destructOK then
							logErrorNonFatal("pairsDestructorError", err)
						end
					end
				end

				-- make the old input match the new input
				oldInput[key] = newInValue
				-- store the new output value for next time we run the output comparison
				oldOutput[key] = newOutValue
				-- store the new output value in the table we give to the user
				newOutput[key] = newOutValue
			else
				-- restore old dependencies, because the new dependencies may be corrupt
				keyData.oldDependencySet, keyData.dependencySet = keyData.dependencySet, keyData.oldDependencySet

				logErrorNonFatal("pairsProcessorError", newOutValue)
			end
		end

		-- save dependency values and add to main dependency set
		for dependency in pairs(keyData.dependencySet) do
			keyData.dependencyValues[dependency] = dependency:get(false)

			self.dependencySet[dependency] = true
			dependency.dependentSet[self] = true
		end
	end

	-- STEP 2: find keys that were removed

	for key in pairs(oldInput) do
		-- if this key doesn't have an equivalent in the new input table
		if newInput[key] == nil then
			-- clean up the old calculated value
			local oldOutValue = oldOutput[key]
			if oldOutValue ~= nil then
				local destructOK, err = xpcall(self._destructor, parseError, oldOutValue)
				if not destructOK then
					logErrorNonFatal("pairsDestructorError", err)
				end
			end

			-- make the old input match the new input
			oldInput[key] = nil
			-- remove the reference to the old output value
			oldOutput[key] = nil
			-- remove the value from the table we give to the user
			newOutput[key] = nil
			-- remove key data
			self._keyData[key] = nil
		end
	end

	return didChange
end

local function ComputedPairs(
	inputTable: Types.StateOrValue<{[any]: any}>,
	processor: (any) -> any,
	destructor: (any) -> ()?
)
	-- if destructor function is not defined, use the default cleanup function
	if destructor == nil then
		destructor = cleanup
	end

	local inputIsState = inputTable.type == "State" and typeof(inputTable.get) == "function"

	local self = setmetatable({
		type = "State",
		kind = "ComputedPairs",
		dependencySet = {},
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_oldDependencySet = {},

		_processor = processor,
		_destructor = destructor,
		_inputIsState = inputIsState,

		_inputTable = inputTable,
		_oldInputTable = {},
		_outputTable = {},
		_oldOutputTable = {},
		_keyData = {}
	}, CLASS_METATABLE)

	initDependency(self)
	self:update()

	return self
end

return ComputedPairs]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010697</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXCB00371B06FE4D8DA81D34EF9F2DED67">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">State</string>
									<string name="ScriptGuid">{8F918A84-EE28-4260-98D1-998EE50B90FC}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Constructs and returns objects which can be used to model independent
	reactive state.
]]

local Package = script.Parent.Parent
local useDependency = require(Package.Dependencies.useDependency)
local initDependency = require(Package.Dependencies.initDependency)
local updateAll = require(Package.Dependencies.updateAll)

local class = {}

local CLASS_METATABLE = {__index = class}
local WEAK_KEYS_METATABLE = {__mode = "k"}

--[[
	Returns the value currently stored in this State object.
	The state object will be registered as a dependency unless `asDependency` is
	false.
]]
function class:get(asDependency: boolean?)
	if asDependency ~= false then
		useDependency(self)
	end
	return self._value
end

--[[
	Updates the value stored in this State object.

	If `force` is enabled, this will skip equality checks and always update the
	state object and any dependents - use this with care as this can lead to
	unnecessary updates.
]]
function class:set(newValue: any, force: boolean?)
	-- if the value hasn't changed, no need to perform extra work here
	if self._value == newValue and not force then
		return
	end

	self._value = newValue

	-- update any derived state objects if necessary
	updateAll(self)
end

local function State(initialValue: any)
	local self = setmetatable({
		type = "State",
		kind = "State",
		-- if we held strong references to the dependents, then they wouldn't be
		-- able to get garbage collected when they fall out of scope
		dependentSet = setmetatable({}, WEAK_KEYS_METATABLE),
		_value = initialValue
	}, CLASS_METATABLE)

	initDependency(self)

	return self
end

return State]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c78100010698</UniqueId>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBXFE038AD0558449A68B94746E8DEB8707">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Types</string>
								<string name="ScriptGuid">{9AFCB808-E006-47AB-9812-9244081632FB}</string>
								<ProtectedString name="Source"><![CDATA[--[[
	Stores Luau type definitions shared across scripts in Fusion.
]]

export type Set<T> = {[T]: any}

export type State<T> = {get: (State<T>) -> T}
export type StateOrValue<T> = State<T> | T

export type Symbol = {
	type: string,
	name: string,
	key: string?
}

export type Error = {
	raw: string,
	message: string,
	trace: string
}

export type Dependency<T> = State<T> & {
	dependentSet: Set<Dependent<any>>
}

export type Dependent<T> = State<T> & {
	update: (Dependent<T>) -> boolean,
	dependencySet: Set<Dependency<any>>
}

export type Animatable =
	number |
	CFrame |
	Color3 |
	ColorSequenceKeypoint |
	DateTime |
	NumberRange |
	NumberSequenceKeypoint |
	PhysicalProperties |
	Ray |
	Rect |
	Region3 |
	Region3int16 |
	UDim |
	UDim2 |
	Vector2 |
	Vector2int16 |
	Vector3 |
	Vector3int16

return nil]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c78100010699</UniqueId>
							</Properties>
						</Item>
						<Item class="Folder" referent="RBX4139FC283CB8400DB644AC0274C48344">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
								<bool name="DefinesCapabilities">false</bool>
								<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
								<string name="Name">Utility</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UniqueId name="UniqueId">35e96ac358fec8160612c7810001069a</UniqueId>
							</Properties>
							<Item class="ModuleScript" referent="RBX8C066F088ADE4350B2B65C708008DCB5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">None</string>
									<string name="ScriptGuid">{B78E9634-6468-47D5-A408-7AFA7B508525}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	A symbol for representing nil values in contexts where nil is not usable.
]]

return {
	type = "Symbol",
	name = "None"
}]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001069b</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX348F3BA130CC4377A775B080C7B45563">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">cleanup</string>
									<string name="ScriptGuid">{6EAC0EA7-6E45-4B22-95EF-D8D4104B9780}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Cleans up the task passed in as the argument.
	A task can be any of the following:

	- an Instance - will be destroyed
	- an RBXScriptConnection - will be disconnected
	- a function - will be run
	- a table with a `Destroy` or `destroy` function - will be called
	- an array - `cleanup` will be called on each item
]]

export type Task =
	Instance |
	RBXScriptConnection |
	() -> () |
	{destroy: (any) -> ()} |
	{Destroy: (any) -> ()} |
	{Task}

local function cleanup(task: Task)
	local taskType = typeof(task)

	-- case 1: Instance
	if taskType == "Instance" then
		task:Destroy()

	-- case 2: RBXScriptConnection
	elseif taskType == "RBXScriptConnection" then
		task:Disconnect()

	-- case 3: callback
	elseif taskType == "function" then
		task()

	elseif taskType == "table" then
		-- case 4: destroy() function
		if typeof(task.destroy) == "function" then
			task:destroy()

		-- case 5: Destroy() function
		elseif typeof(task.Destroy) == "function" then
			task:Destroy()

		-- case 6: array of tasks
		elseif task[1] ~= nil then
			for _, subtask in ipairs(task) do
				cleanup(subtask)
			end
		end
	end
end

return cleanup]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001069c</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX87C8288BEF804DA38D97DA3130652154">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">cleanupOnDestroy</string>
									<string name="ScriptGuid">{7B593C97-782F-4B32-BCF3-EADCDCB068D5}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Functions like a hypothetical 'Instance.Destroyed' event - when the instance
	is destroyed, cleans up the given task using the default `cleanup` function.
	Returns a function which can be called to stop listening for destruction.

	Relying on this function is dangerous - this should only ever be used when
	no more suitable solution exists. In particular, it's almost certainly the
	wrong solution if you're not dealing with instances passed in by the user.

	NOTE: yes, this uses polling. I've been working on making this function
	work better with events for months, and even then I can't avoid polling. I
	just want something that works in all edge cases, even it if might not be
	the theoretically best solution. This is the best choice for the short term.

	You can find the 'better' version with less polling in the
	`cleanupOnDestroy_smart` file if you're interested in helping out :)
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local cleanup = require(Package.Utility.cleanup)

type TaskData = {
	connection: RBXScriptConnection,
	task: cleanup.Task,
	cleaned: boolean
}

local function noOp()
	-- intentionally blank - no operation!
end

local tasks: {TaskData} = {}
local numTasks = 0
local currentIndex = 1

-- called to check for dead connections and run their cleanup tasks
local function runCleanupTasks()
	if numTasks == 0 then
		return
	end

	-- we want to clean as much stuff up as possible, but we don't want to hang
	-- the client, so we forcibly terminate after a short while
	local startTime = os.clock()
	local endTime = startTime + 1/1000

	-- run at most `numTask` times
	for _=1, numTasks do
		local taskData = tasks[currentIndex]

		if taskData.connection.Connected then
			-- instance is still alive, so move on to the next task
			currentIndex += 1
		else
			-- instance destroyed, so run cleanup and remove the task
			taskData.cleaned = true
			-- print("cleaning up", taskData.debugName)
			cleanup(taskData.task)

			table.remove(tasks, currentIndex)
			numTasks -= 1
		end

		-- wrap around if we passed the end of the task list
		if currentIndex > numTasks then
			currentIndex = 1
		end

		-- if this took too long, exit early to avoid hanging
		if os.clock() > endTime then
			break
		end
	end
end

RunService.Heartbeat:Connect(runCleanupTasks)

local function cleanupOnDestroy(instance: Instance, task: cleanup.Task): (() -> ())
	-- set up connection so we can check if the instance is alive
	-- we don't care about the event we're connecting to, just that we can see
	-- when it's disconnected by the garbage collector
	local connection = instance:GetPropertyChangedSignal("ClassName"):Connect(noOp)

	-- store data about the task for later
	local taskData = {
		debugName = instance.Name,
		connection = connection,
		task = task,
		cleaned = false
	}

	-- remove instance reference so we don't accidentally inhibit gc
	instance = nil

	-- add task to list
	numTasks += 1
	tasks[numTasks] = taskData

	-- return disconnect function to stop listening for destroy
	return function()
		if taskData.cleaned then
			return
		end

		taskData.cleaned = true
		connection:Disconnect()

		local index = table.find(tasks, taskData)
		if index ~= nil then
			table.remove(tasks, index)
			numTasks -= 1
		end
	end
end

return cleanupOnDestroy]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001069d</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBXD66D5CCDD3AB49168C0033508011BCA0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">cleanupOnDestroy_smart</string>
									<string name="ScriptGuid">{747EB545-6BFB-4D70-BA5B-8BBAA5B07117}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	The 'smarter' version of `cleanupOnDestroy` - this attempts to match the
	results from the 'dumber' polling-based version by using events to reduce
	processing.

	I'd like to improve this technique in the future - it breaks in a fair few
	edge cases right now, so in the interest of stability I don't want to adopt
	it yet.
]]

local RunService = game:GetService("RunService")

local Package = script.Parent.Parent
local cleanup = require(Package.Utility.cleanup)

-- The event to use for waiting (typically Heartbeat)
local STEP_EVENT = RunService.Heartbeat

local function cleanupOnDestroy(instance: Instance?, task: cleanup.Task): (() -> ())
	-- set up manual disconnection logic
	local isDisconnected = false
	local ancestryChangedConn

	local function disconnect()
		if not isDisconnected then
			isDisconnected = true
			ancestryChangedConn:Disconnect()
		end
	end

	-- We can't keep a reference to the instance, but we need to keep track of
	-- when the instance is parented to `nil`.
	-- To get around this, we can save the parent from AncestryChanged here
	local isNilParented = instance.Parent == nil

	-- when AncestryChanged is called, run some destroy-checking logic
	-- this function can yield when called, so make sure to call in a new thread
	-- if you don't want your current thread to block
	local function onInstanceMove(_doNotUse: Instance?, newParent: Instance?)
		if isDisconnected then
			return
		end

		-- discard the first argument so we don't inhibit GC
		_doNotUse = nil

		isNilParented = newParent == nil

		-- if the instance has been moved into a nil parent, it could possibly
		-- have been destroyed if no other references exist
		if isNilParented then
			-- We don't want this function to yield, because it's called
			-- directly from the main body of `connectToDestroy`
			coroutine.wrap(function()
				-- This delay is needed because the event will always be connected
				-- when it is first run, but we need to see if it's disconnected as
				-- a result of the instance being destroyed.
				STEP_EVENT:Wait()

				if isDisconnected then
					return

				elseif not ancestryChangedConn.Connected then
					-- if our event was disconnected, the instance was destroyed
					cleanup(task)
					disconnect()

				else
					-- The instance currently still exists, however there's a
					-- nasty edge case to deal with; if an instance is destroyed
					-- while in nil, `AncestryChanged` won't fire, because its
					-- parent will have changed from nil to nil.

					-- For this reason, we set up a loop to poll
					-- for signs of the instance being destroyed, because we're
					-- out of event-based options.
					while
						isNilParented and
						ancestryChangedConn.Connected and
						not isDisconnected
					do
						-- FUTURE: is this too often?
						STEP_EVENT:Wait()
					end

					-- The instance was either destroyed, or we stopped looping
					-- for another reason (reparented or `disconnect` called)
					-- Check those other conditions before calling the callback.
					if isDisconnected or not isNilParented then
						return
					end

					cleanup(task)
					disconnect()
				end
			end)()
		end
	end

	ancestryChangedConn = instance.AncestryChanged:Connect(onInstanceMove)

	-- in case the instance is currently in nil, we should call `onInstanceMove`
	-- before any other code has the opportunity to run
	if isNilParented then
		onInstanceMove(nil, instance.Parent)
	end

	-- remove this functions' reference to the instance, so it doesn't influence
	-- any garbage collection and cause memory leaks
	instance = nil

	return disconnect
end

return cleanupOnDestroy]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001069e</UniqueId>
								</Properties>
							</Item>
							<Item class="ModuleScript" referent="RBX6367AB41C7D84873AC12990051EE8D6E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
									<bool name="DefinesCapabilities">false</bool>
									<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">restrictRead</string>
									<string name="ScriptGuid">{440D786F-83A2-41AD-A397-D95B54C6F2FA}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Restricts the reading of missing members for a table.
]]

local Package = script.Parent.Parent
local logError = require(Package.Logging.logError)

local function restrictRead(tableName: string, strictTable: table): table
	local metatable = getmetatable(strictTable)

	if metatable == nil then
		metatable = {}
		setmetatable(strictTable, metatable)
	end

	function metatable:__index(memberName)
		logError("strictReadError", nil, tostring(memberName), tableName)
	end

	return strictTable
end

return restrictRead]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UniqueId name="UniqueId">35e96ac358fec8160612c7810001069f</UniqueId>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXB1A687A9CFEE427E9467014E22EBF653">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Fusion</string>
					<string name="ScriptGuid">{62C3328A-BBD2-43E0-BCD4-E0E9ADE39464}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["elttob_fusion@0.1.1-beta"]["fusion"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">35e96ac358fec8160612c781000106cf</UniqueId>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXE0FCC2500183480299A098706C658BED">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
					<bool name="DefinesCapabilities">false</bool>
					<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Koute</string>
					<string name="ScriptGuid">{00F119AD-AD5A-4EA3-93C2-F25D3BB09348}</string>
					<ProtectedString name="Source"><![CDATA[return require(script.Parent._Index["7kayoh_koute@1.0.2"]["koute"])
]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<UniqueId name="UniqueId">35e96ac358fec8160612c781000106d5</UniqueId>
				</Properties>
			</Item>
		</Item>
	</Item>
	<Item class="LuaWebService" referent="RBX884C57D2C53C4F6292C9F2D9FD2A78F0">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LuaWebService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008960</UniqueId>
		</Properties>
	</Item>
	<Item class="ProcessInstancePhysicsService" referent="RBX7B1F62B60CFD4BEC92BDD29880EEC0A8">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ProcessInstancePhysicsService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008962</UniqueId>
		</Properties>
	</Item>
	<Item class="Lighting" referent="0">
		<Properties>
			<Color3 name="Ambient">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<float name="Brightness">2</float>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<Color3 name="ColorShift_Bottom">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<Color3 name="ColorShift_Top">
				<R>0</R>
				<G>0</G>
				<B>0</B>
			</Color3>
			<bool name="DefinesCapabilities">false</bool>
			<float name="EnvironmentDiffuseScale">0</float>
			<float name="EnvironmentSpecularScale">0</float>
			<float name="ExposureCompensation">0</float>
			<Color3 name="FogColor">
				<R>0.75</R>
				<G>0.75</G>
				<B>0.75</B>
			</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<bool name="GlobalShadows">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Lighting</string>
			<Color3 name="OutdoorAmbient">
				<R>0.5</R>
				<G>0.5</G>
				<B>0.5</B>
			</Color3>
			<bool name="Outlines">false</bool>
			<float name="ShadowSoftness">0.5</float>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<token name="Technology">1</token>
			<string name="TimeOfDay">14:00:00</string>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008977</UniqueId>
		</Properties>
	</Item>
	<Item class="LodDataService" referent="RBX9C85FE9559D14D9690D89DF1AE0A9225">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">LodDataService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c78100008994</UniqueId>
		</Properties>
	</Item>
	<Item class="ServiceVisibilityService" referent="RBX6AD4A5550638459995C76AE80DE77497">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<BinaryString name="HiddenServices">AAAAAA==</BinaryString>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">ServiceVisibilityService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000c2a2</UniqueId>
			<BinaryString name="VisibleServices">AAAAAA==</BinaryString>
		</Properties>
	</Item>
	<Item class="HttpService" referent="RBX9232C35ACDDA4A288C9BBD74FF5646D7">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="HttpEnabled">false</bool>
			<string name="Name">HttpService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000c2ad</UniqueId>
		</Properties>
	</Item>
	<Item class="TestService" referent="RBX3B487CD560894053B5C52EB0889E6096">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutoRuns">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Description"></string>
			<bool name="ExecuteWithStudioRun">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="IsSleepAllowed">true</bool>
			<string name="Name">TestService</string>
			<int name="NumberOfPlayers">0</int>
			<double name="SimulateSecondsLag">0</double>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<double name="Timeout">10</double>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000c2ba</UniqueId>
		</Properties>
	</Item>
	<Item class="UGCAvatarService" referent="RBX6930ED4E2D264F5BBE77B0C89DC5015A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">UGCAvatarService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000c2c0</UniqueId>
		</Properties>
	</Item>
	<Item class="VirtualInputManager" referent="RBX0A78998F3E204DADB647144DF3FC6F9D">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">VirtualInputManager</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000c2c8</UniqueId>
		</Properties>
	</Item>
	<Item class="PluginToolbarButton" referent="RBX6D7BCD6CE81642A889239996C1A0D742">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Mesh EditorButton</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000c367</UniqueId>
		</Properties>
	</Item>
	<Item class="PluginToolbar" referent="RBX7CD2604521BA4989B0655B27F236EEF4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<string name="Name">Wolfite</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000daac</UniqueId>
		</Properties>
		<Item class="PluginToolbarButton" referent="RBXD11A9CC26DBD474BB43EB57817CE62E9">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
				<string name="Name">LoadRobloxCharacters</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
				<UniqueId name="UniqueId">35e96ac358fec8160612c7810000daad</UniqueId>
			</Properties>
		</Item>
	</Item>
	<Item class="ProximityPromptService" referent="RBXECBA2C2FE5684D2594414B3F0B4EB8D5">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<bool name="Enabled">true</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<int name="MaxPromptsVisible">16</int>
			<string name="Name">ProximityPromptService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000db80</UniqueId>
		</Properties>
	</Item>
	<Item class="DataStoreService" referent="RBXEAD6A392E4ED42C0B707B34F05C7816A">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<bool name="AutomaticRetry">true</bool>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<UniqueId name="HistoryId">00000000000000000000000000000000</UniqueId>
			<bool name="LegacyNamingScheme">false</bool>
			<string name="Name">DataStoreService</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
			<UniqueId name="UniqueId">35e96ac358fec8160612c7810000ded2</UniqueId>
		</Properties>
	</Item>
	<SharedStrings>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>